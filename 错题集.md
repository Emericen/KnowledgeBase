1. max water trapped / largest rec w ones
3. Solution to tree reconstruction w level order and in order list
4. Priority Queue comparator order
5. List to array and array to list in java
9. Hashing function

# Basics



## 1. Merge Sort W Helper List

We are already familiar with regular merge sort that takes TC = O(nlogn) and SC = O(nlogn), but we can optimize space complexity to O(n) by using a helper array and guarantee that no more than O(n) space is used, here's how

```java
public class Solution {
    // assuming array is not null
    public int[] mergeSort(int[] array) {
        int[] helper = new int[array.length];
        mergeSort(array, helper, 0, array.length - 1);
        return array;
    }
    
    private void mergeSort(int[] array, int[] helper, int left, int right) {
        if (left >= right) {
            return;
        }
        int mid = left + (right - left) / 2;
        mergeSort(array, helper, left, mid);
        mergeSort(array, helper, mid + 1, right);
        merge(array, helper, left, mid, right);
    }
    
    private void merge(int[] array, int[] helper, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            helper[i] = array[i];
        }
        int i = left;
        int j = mid + 1;
        while (i <= mid && j <= right) {
            if (helper[i] <= helper[j]) {
                array[left++] = helper[i++];
            } else {
                array[left++] = helper[j++];
            }
        }
        while (i <= mid) {
            array[left++] = helper[i++];
        }
    }
}
```



## 2. Linked List 

### 2.1. Reverse Linked List 

The List node class looks like this

```java
public class ListNode {
    public int value;
    public ListNode next;
    public ListNode(int value) {
        this.value = value;
        next = null;
    }
}
```

Here's how you do a reverse in both iterative and recursive way

```java
public class Solution {
    // Iterative
    public ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode L = null;
        ListNode C = head;
        ListNode N = head.next;
        while (N != null) {
            C.next = L;
            L = C;
            C = N;
            N = N.next;
        }
        C.next = L;
        return C;
    }
    
    // Recursive
    public ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode sub = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return sub;
    }
}
```



### 2.2. Reverse In pairs

Reverse pairs of elements in a singly-linked list.

**Examples**

- L = null, after reverse is null
- L = 1 -> null, after reverse is 1 -> null
- L = 1 -> 2 -> null, after reverse is 2 -> 1 -> null
- L = 1 -> 2 -> 3 -> null, after reverse is 2 -> 1 -> 3 -> null

**Answer**

```java
public class Solution {
    // Recursive
    public ListNode reverseInPairs(ListNode head) {
    	if (head == null || head.next == null) {
            return head;
        }   
        ListNode newHead = head.next;
        head.next = reverseInPairs(head.next.next);
        newHead.next = head;
        return newHead;
    }
    
    // Iterative
    public ListNode reverseInPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = dummy;
        while (cur.next != null && cur.next.next != null) {
            ListNode next = cur.next.next;
            cur.next.next = cur.next.next.next;
            next.next = cur.next;
            cur.next = next;
            cur = cur.next.next;
        }
        return dummy.next;
    }
}               
```



### 2.3. Reverse Binary Tree

Given a binary tree where all the right nodes are leaf nodes, flip it upside down and turn it into a tree with left leaf nodes as the root.

**Examples**

```
        1                           3
      /    \                      /   \
    2        5         =>        2     4   
  /   \                        /   \
3      4                      1     5
```

**Answer**

```java
public class Solution {
    // TC = O(height)
    // SC = O(height)
    public TreeNode reverse(TreeNode root) {
        if (root == null || root.left == null) {
            return root;
        }
        TreeNode newRoot = reverse(root.left);
        root.left.right = root.right;
        root.left.left = root;
        root.left = null;
        root.right = null;
        return newRoot;
    }
}
```



### 2.4. Deep Copy Random Linked List

Each of the nodes in the linked list has another pointer pointing to a random node in the list or null. Make a deep copy of the original list.

```java
public class RandomListNode {
    public int value;
    public RandomListNode next;
    public RandomListNode random;
    public RandomListNode(int value) {
        this.value = value;
    }
}
```

**Answer**

```java
public class Solution {
    public RandomListNode copy(RandomListNode head) {
        if (head == null) {
            return head;
        }
        
        RandomListNode dummy = new RandomListNode(0);
        RandomListNode cur = dummy;
        Map<RandomListNode, RandomListNode> map = new HashMap<>();
        
        while (head != null) {
            if (!map.containsKey(head)) {
                map.put(head, new RandomListNode(head.value));
            }
            
            cur.next = map.get(head);
            
            if (head.random != null) {
                if (!map.containsKey(head.random)) {
                    map.put(head.random, new RandomListNode(head.random.value));
                }
                cur.next.random = map.get(head.random);
            }
            
            head = head.next;
            cur = cur.next;
        }
        return dummy.next;
    }
}
```



## 3. 2D Array Traversal

### 3.1. Rotate Matrix

Rotate an N * N matrix clockwise 90 degrees.

**Assumptions**

- The matrix is not null and N >= 0

**Examples**

```
{ {1,  2,  3}
  {8,  9,  4}
  {7,  6,  5} }

after rotation is

{ {7,  8,  1}
  {6,  9,  2}
  {5,  4,  3} }
```

**Answer**

```java
public class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        
        if (n == 0 || n == 1) {
            return;
        }
        
        for (int i = 0; i < n / 2; i++) {
            for (int j = i; j < n - i - 1; j++) {
                swap(matrix, i, j, j, n - i - 1);
                swap(matrix, i, j, n - i - 1, n - j - 1);
                swap(matrix, i, j, n - j - 1, i);
            }
        }
    }
    
    private void swap(int[][] matrix, int i, int j, int x, int y) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[x][y];
        matrix[x][y] = temp;
    }
}
```

<img src="C:\Users\EddyM\Desktop\KnowledgeBase\Assets\Rotating Rectangle.jpg" alt="Rotating Rectangle" style="zoom:50%;" />



## 4. Binary Tree

### 4.1. LCA II

Given two nodes in a binary tree (with parent pointer available), find their lowest common ancestor.

**Assumptions**

- There is **parent** pointer for the nodes in the binary tree
- The given two nodes are not guaranteed to be in the binary tree

**Example**

```
        5
      /   \
     9     12
   /  \      \
  2    3      14

The lowest common ancestor of 2 and 14 is 5
The lowest common ancestor of 2 and 9 is 9
The lowest common ancestor of 2 and 8 is null (8 is not in the tree)
```

```java
public class TreeNodeP {
    public int key;
    public TreeNodeP left;
    public TreeNodeP right;
    public TreeNodeP parent;
    public TreeNodeP(int key, TreeNodeP parent) {
        this.key = key;
        this.parent = parent;
    }
}
```

**Answer**

```java
public class Solution {
    public TreeNodeP LCA(TreeNodeP one, TreeNodeP two) {
        int l1 = length(one);
        int l2 = length(two);
        if (l1 <= l2) {
            return mergeNode(one, two, l2 - l1);
        } else {
            return mergeNode(two, one, l1 - l2);
        }
    }
    
    private TreeNodeP mergeNode(TreeNodeP shorter, TreeNodeP longer, int diff) {
        while (diff > 0) {
            longer = longer.parent;
            diff--;
        }
        while (longer != shorter) {
            longer = longer.parent;
            shorter = shorter.parent;
        }
        return shorter;
    }
    
    private int length(TreeNodeP node) {
        int length = 0;
        while (node != null) {
            length++;
            node = node.parent;
        }
        return length;
    }
}
```



### 4.2. Closest Number in BST II

In a binary search tree, find k nodes containing the closest numbers to the given target number. return them in sorted array

**Assumptions:**

- The given root is not null.
- There are no duplicate keys in the binary search tree.

**Examples:**

```
    5
  /    \
2      11
     /    \
    6     14

closest number to 4 is 5
closest number to 10 is 11
closest number to 6 is 6
```

**Answer:**

```java
public class Solution {
    // stk  = [ 
    // list = [2 5]
    // node = 11
    public int[] closestKValues(TreeNode root, double target, int k) {
        Queue<Integer> list = new LinkedList<>();
        Stack<TreeNode> stk = new Stack<>();
        TreeNode node = root;
        while (!stk.isEmpty() || node != null) {
            while (node != null) {
                stk.push(node);
                node = node.left;
            }
            
            node = stk.pop();
            
            if (list.size() < k) {
                list.offer(node.key);
            } else {
                if (Math.abs(list.peek() - target) > Math.abs(node.key - target)) {
                    list.poll();
                    list.offer(node.key);
                } 
            }
            node = node.right;
        }
        int[] result = new int[list.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = list.poll();
        }
        return result;
    }
}
```

But here is a recursion, non-iterative way that is meant for human brain :) Eddy wrote it himself

```java
public class Solution {
    public int[] closestKValues(TreeNode root, double target, int k) {
        Queue<Integer> list = new LinkedList<>();
        helper(root, target, new int[]{k}, list);
        int[] result = new int[list.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = list.poll();
        }
        return result;
    }
    
    private void helper(TreeNode root, double target, int[] k, Queue<Integer> list) {
        if (root == null) {
            return;
        }
        helper(root.left, target, k, list);
        if (k[0] > 0) {
            list.offer(root.key);
            k[0] -= 1;
        } else {
            if (Math.abs(list.peek() - target) > Math.abs(root.key - target)) {
                list.poll();
                list.offer(root.key);
            }
        }
        helper(root.right, target, k, list);
    }
}
```

Here's the idea, imagine you're asked to find closest numbers in a sorted array in TC = O(N) 

```
[1,3,4,5,7,9,10]
target = 6, k = 3

Recall that with unsorted array, we used priority queue. 
However, in a sorted one, we'll use a regular queue and we do the same thing

for entry in array:
	if queue.size < k:
		queue.offer(entry)
	else:
		if queue.peek has lower priority than entry (further to target in this case):
			queue.poll
			queue.offer(entry)

this will give you k elements from the array with the highest priority
whatever that priority may be
```



### 4.3. LCA V

Given two nodes in a K-nary tree, find their lowest common ancestor.

**Assumptions**

-There is no parent pointer for the nodes in the K-nary tree.

-The given two nodes are guaranteed to be in the K-nary tree

**Examples**

```java
public class KnaryTreeNode {
    int key;
    List<KnaryTreeNode> children;
    public KnaryTreeNode(int key) {
        this.key = key;
        this.children = new ArrayList<>();
    }
}
```

```
        5
      /   \
     9     12
   / | \      \
  1  2  3      14

The lowest common ancestor of 2 and 14 is 5.
The lowest common ancestor of 2 and 9 is 9.
```

**Answer**

```java
public class Solution {
    public KnaryTreeNode LCA(KnaryTreeNode root, KnaryTreeNode a, KnaryTreeNode b) {
        if (root == null || root == a || root == b) {
            return root;
        }
        KnaryTreeNode found = null;
        for (KnaryTreeNode child : root.children) {
            KnaryTreeNode node = LCA(child, a, b);
            if (node == null) {
                continue;
            }
            if (found == null) {
                found = node;
            } else {
                return root;
            }
        }
        return found;
    }
}
```





## 5. Data Structure Operation

### 5.1. Subdomain Visit Count

 website domain `"discuss.leetcode.com"` consists of various subdomains. At the top level, we have `"com"`, at the next level, we have `"leetcode.com"` and at the lowest level, `"discuss.leetcode.com"`. When we visit a domain like `"discuss.leetcode.com"`, we will also visit the parent domains `"leetcode.com"` and `"com"` implicitly.

A **count-paired domain** is a domain that has one of the two formats `"rep d1.d2.d3"` or `"rep d1.d2"` where `rep` is the number of visits to the domain and `d1.d2.d3` is the domain itself.

- For example, `"9001 discuss.leetcode.com"` is a **count-paired domain** that indicates that `discuss.leetcode.com` was visited `9001` times.

Given an array of **count-paired domains** `cpdomains`, return *an array of the **count-paired domains** of each subdomain in the input*. You may return the answer in **any order**.

**Example 1:**

```
Input: cpdomains = ["9001 discuss.leetcode.com"]
Output: ["9001 leetcode.com","9001 discuss.leetcode.com","9001 com"]
Explanation: We only have one website domain: "discuss.leetcode.com".
As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.
```

**Example 2:**

```
Input: cpdomains = ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output: ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
Explanation: We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times.
For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.
```

**Solution**

```java
class Solution {
    public List<String> subdomainVisits(String[] cpdomains) {
        Map<String, Integer> counts = new HashMap<>();
        for (String domain: cpdomains) {
			List<String> frags = readAddress(domain);
            int count = readCount(domain);
            String cur = "";
            for (int i = frags.size() - 1; i >= 0; --i) {
                cur = frags.get(i) + (i < frags.size() - 1 ? "." : "") + cur;
                if (counts.get(cur) != null) {
                    counts.put(cur, counts.get(cur) + count);
                } else {
                    counts.put(cur, count);
                }
            }
        }

        List<String> ans = new ArrayList<>();
        for (String dom: counts.keySet()) {
			ans.add("" + counts.get(dom) + " " + dom);
		}
        return ans;
    }

	private int readCount(String str) {
        int i = 0;
        while (str.charAt(i) != ' ') {
            i++;
        }
        return Integer.parseInt(str.substring(0, i));
    }
    
    private List<String> readAddress(String str) {
        int i = 0;
        while (str.charAt(i) != ' ') {
            i++;
        }
        i++;
        int j = i;
        List<String> result = new ArrayList<>();
        while (i < str.length()) {
            if (j < str.length() && str.charAt(j) != '.') {
                j++;
            } else {
                result.add(str.substring(i, j));
                j++;
                i = j;
            }
        }
        return result;
    }
}
```



### 5.2. Top K Frequent Elements

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

**Solution**

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        if (k == nums.length) {
            return nums;
        }
        
        Map<Integer, Integer> count = new HashMap();
        for (int n : nums) {
            count.put(n, count.getOrDefault(n, 0) + 1);
        }
        
        Queue<Integer> heap = new PriorityQueue<>(
            (a, b) -> count.get(a) - count.get(b));
        
        for (int n : count.keySet()) {
            heap.add(n);
            if (heap.size() > k) {
                heap.poll();
            }
        }
        
        int[] top = new int[k];
        for (int i = k - 1; i >= 0; i--) {
            top[i] = heap.poll();
        }
        return top;
    }
}
```



## 6. Strings

### 6.1. 12-hour clock to 24-hour

```java
	public static void main(String[] args) {
		String a = "07:01:01PM";
		String[] time = a.substring(0, a.length() - 2).split("\\:");
		String state = a.substring(a.length() - 2, a.length());
		
		StringBuilder str = new StringBuilder();
		for (int i = 0; i < time.length; i++) {
			String t = time[i];
			if (i == 0) {
				int value = stringToInt(t);
				if (state.equals("PM")) {
					value = value == 12 ? value : value + 12;
				} else if (state.equals("AM")) {
					value = value == 12 ? 0 : value;
				}
				t = intToString(value);
			}
			str.append(t).append(":");
		}
		
		System.out.println(str.substring(0, str.length() - 1));

	}

	private static int stringToInt(String str) {
		int result = 0;
		for (int i = 0; i < str.length(); i++) {
			result = result * 10 + (str.charAt(i) - '0');
		}
		return result;
	}

	private static String intToString(int num) {
		StringBuilder str = new StringBuilder();
		while (num != 0) {
			str.insert(0, (char)('0' + (num % 10)));
			num /= 10;
		}
		while (str.length() < 2) {
			str.insert(0, '0');
		}
		return str.toString();
	}
}
```



# Graph

## 1. Course Schedule

### 1.1 Course Schedule I

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

- For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return `true` if you can finish all courses. Otherwise, return `false`.

 

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
```

**Example 2:**

```
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
```

**Solution**

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Node> graph = transform(numCourses, prerequisites);
        return !hasCircle(graph);
    }
    
    private List<Node> transform(int num, int[][] connections) {
        Map<Integer, Node> map = new HashMap<>();
        List<Node> result = new ArrayList<>();
        for (int i = 0; i < num; i++) {
            Node node = new Node(i);
            map.put(i, node);
            result.add(node);
        }
        for (int i = 0; i < connections.length; i++) {
            Node a = map.get(connections[i][0]);
            Node b = map.get(connections[i][1]);
            b.neighbors.add(a);
        }
        return result;
    }
    
    private boolean hasCircle(List<Node> graph) {
        Set<Node> seen = new HashSet<>();
        Set<Node> path = new HashSet<>();
        for (int i = 0; i < graph.size(); i++) {
            if (hasCircle(graph.get(i), seen, path)) {
                return true;
            }
        }
        return false;
    }
    
    private boolean hasCircle(Node cur, Set<Node> seen, Set<Node> path) {
        if (seen.contains(cur)) {
            return false;
        }

        if (path.contains(cur)) {
            return true;
        }

        path.add(cur);
        boolean ret = false;
        for (Node child : cur.neighbors) {
            ret = hasCircle(child, seen, path);
            if (ret) {
                break;
            }
        }
        path.remove(cur);
        seen.add(cur);
        return ret;
    }    
}

class Node {
    public int value;
    public List<Node> neighbors;
    public Node(int value) {
        this.value = value;
        this.neighbors = new ArrayList<>();
    }
}
```



### 1.2 Course Schedule II

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

- For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return *the ordering of courses you should take to finish all courses*. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.

 

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
```

**Example 2:**

```
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
```

**Example 3:**

```
Input: numCourses = 1, prerequisites = []
Output: [0]
```

**Solution**

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        
        int[] topologicalOrder = new int[numCourses];
        
        List<Node> graph = transform(numCourses, prerequisites);
        Queue<Node> queue = new LinkedList<>();
        for (Node node : graph) {
            if (node.indegree == 0) {
                queue.add(node);
            }
        }
        
        int i = 0;
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            topologicalOrder[i++] = node.value;
            
            for (Node neighbor : node.neighbors) {
                neighbor.indegree--;
                if (neighbor.indegree == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        if (i == numCourses) {
            return topologicalOrder;
        }
        return new int[0];
    }
    
    private List<Node> transform(int num, int[][] connections) {
        Map<Integer, Node> map = new HashMap<>();
        List<Node> result = new ArrayList<>();
        for (int i = 0; i < num; i++) {
            Node node = new Node(i);
            map.put(i, node);
            result.add(node);
        }
        for (int i = 0; i < connections.length; i++) {
            Node a = map.get(connections[i][1]);
            Node b = map.get(connections[i][0]);
            a.neighbors.add(b);
            b.indegree++;
        }
        return result;
    }
}

class Node {
    public int value;
    public List<Node> neighbors;
    public int indegree;
    
    public Node(int value) {
        this.value = value;
        this.neighbors = new ArrayList<>();
        this.indegree = 0;
    }
}
```



## 2. Walls and Gates

You are given an `m x n` grid `rooms` initialized with these three possible values.

- `-1` A wall or an obstacle.
- `0` A gate.
- `INF` Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.

Fill each empty room with the distance to *its nearest gate*. If it is impossible to reach a gate, it should be filled with `INF`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/03/grid.jpg)

```
Input: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]
```

**Example 2:**

```
Input: rooms = [[-1]]
Output: [[-1]]
```

**Solution**

```java
class Solution {
    private static final int EMPTY = Integer.MAX_VALUE;
    private static final int GATE = 0;
    private static final List<int[]> DIRECTIONS = Arrays.asList(
        new int[] {1, 0},
        new int[] {-1, 0},
        new int[] {0, 1},
        new int[] {0, -1}
    );
    
    public void wallsAndGates(int[][] rooms) {
        final int M = rooms.length;
        final int N = rooms[0].length;
        
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (rooms[i][j] == GATE) {
                    queue.add(new int[] {i, j});
                }
            }
        }
        
        while (!queue.isEmpty()) {
            int[] point = queue.poll();
            int row = point[0];
            int col = point[1];
            
            for (int[] direction : DIRECTIONS) {
                int r = row + direction[0];
                int c = col + direction[1];
                if (r < 0 || c < 0 || r >= M || c >= N || rooms[r][c] != EMPTY) {
                    continue;
                }
                rooms[r][c] = rooms[row][col] + 1;
                queue.add(new int[] {r, c});
            }
        }
    }
}
```



# DFS

## 1. Integer in String Operation

### 1.1. Find all possible decode ways.

The decoding scheme is 

```
1 -> A
2 -> B
3 -> C
...
26 -> Z
```

Therefore, an example can be

```
1121 -> [AABA, AAU, ALA, KBA, KU]
```

**Answer**

```java
public class Solution {
    public List<String> solve(String input) {
        List<String> result = new ArrayList<>();
        StringBuilder str = new StringBuilder();
        helper(elements, 0, str, result);
    }
    
    private void helper(String input, int index, StringBuilder str, List<String> result) {
        if (index == elements.length) {
            result.add(str.toString());
            return;
        }
        
        // Decode plan #1: read as one digit
        int number = input.charAt(index) - '0';
        if (number >= 1 && number <= 9) {
            char cur = (char)(number - 1 + 'A');
            str.append(cur);
            helper(input, index + 1, str, result);
            str.deleteCharAt(str.length() - 1);
        }
        
        // Decode Plan #2: read as two digits
        if (index + 1 < input.length()) {
            number = (input.charAt(index) - '0') * 10 + (input.charAt(index + 1) - '0');
            if (number >= 10 && number <= 26) {
                char cur = (char)(number - 1 + 'A');
                str.append(cur);
            	helper(input, index + 2, str, result);
            	str.deleteCharAt(str.length() - 1);
            }
        }
    }
}
```





### 1.2. Restore IP address

Given a string containing only digits, restore it by retiring all possible valid IP address combinations.

```
Input:  ”25525511135”
Output: [“255.255.11.135”, “255.255.111.35”]
```

**Answer**

```java
public class Solution {
	public List<String> restore(String input) {
        List<String> result = new ArrayList<>();
        StringBuilder str = new StringBuilder();
        char[] elements = input.toCharArray();
        helper(elements, 0, str, result);
        return result;
    }	
    
    private void helper(char[] elements, int index, int interval, StringBuilder str, List<String> result) {
        if (interval == 4) {
            if (index == elements.length) {
            	result.add(str.substring(0, str.length() - 1));
        	}
            return;
        }
        
        // Decode plan #1: read as one digit
        if (index < elements.length) {
            str.append(elements[index]).append('.');
            helper(elements, index + 1, interval + 1, str, result);
            str.delete(str.length() - 2, str.length());
        }
        
        // Decode Plan #2: read as two digits
        if (index + 1 < elements.length) {
            char a = elements[index];
            char b = elements[index + 1];
            if (a != '0') {   // Note just a minor detail: intervals in IP addresses don't start with 0
                str.append(a).append(b).append('.');
                helper(elements, index + 2, interval + 1, str, result);
                str.delete(str.length() - 3, str.length());
            }
        }
        
        // Decode Plan #3: read as three digits
        if (index + 2 < elements.length) {
            char a = elements[index];
            char b = elements[index + 1];
            char c = elements[index + 2];
            if ((a == '1') || 
                (a == '2' && b < '5') || 
                (a == '2' && b == '5' && c <= '5')) {      // the # must be in [100, 255]
                str.append(a).append(b).append(c).append('.');
                helper(elements, index + 3, interval + 1, str, result);
                str.delete(str.length() - 4, str.length());
            }
        }
    }
}
```



## 2. Swapping Permutation

### 2.1. Keep Distance For Identical Elements

Given an integer k, arrange the sequence of integers [1, 1, 2, 2, 3, 3, ...., k - 1, k - 1, k, k], such that the output integer array satisfy this condition:

Between each two i's, they are exactly i integers (for example: between the two 1s, there is one number, between the two 2's there are two numbers).

**If there does not exist such sequence, return null.**

**Assumptions:**

- k is guaranteed to be > 0

**Examples:**

- k = 3, The output = { 2, 3, 1, 2, 1, 3 }.



**Answer**: 

You are already familiar with the usual N-Queen method:

```
                          xxxxx
                 /                      \
3?            3xxx3x                    x3xxx3
            /       \                /          \
2?   32xx3x NO     3x2x32      23x2x3          x32xx3 NO
                     |            |
1?                 312132      231213
```

```java
public class Solution {
    public int[] keepDistance(int k) {
        int[] array = new int[k * 2];
        return helper(array, k) ? array : null;
    }
    
    private boolean helper(int[] array, int k) {
        if (k == 0) {
            return true;
        }
        for (int i = 0; i + k + 1 < array.length; i++) {
            if (array[i] == 0 && array[i + k + 1] == 0) {
                array[i] = k;
                array[i + k + 1] = k;
                if (helper(array, k - 1)) {
                    return true;
                }
                array[i] = 0;
                array[i + k + 1] = 0;
            }
        }
        return false;
    }
}
```

Here is the swap method

```java
public class Solution {
    public int[] keepDistance(int k) {
        int[] array = new int[2 * k];
        for (int i = 0; i < k; i++) {
            array[i * 2] = i + 1;
            array[i * 2 + 1] = i + 1;
        }
        boolean[] used = new boolean[k + 1];
        return helper(array, 0, used) ? array : null;
    }

    private boolean helper(int[] array, int index, boolean[] used) {
        if (index == array.length) {
            return true;
        }
        for (int i = index; i < array.length; i++) {
            int cur = array[i];
            if (!used[cur] || (index > cur && array[index - cur - 1] == cur)) {
                swap(array, index, i);
                used[cur] != used[cur];
                if (helper(array, index + 1, used)) {
                    return true;
                }
                swap(array, index, i);
                used[cur] != used[cur];
            }
        }
        return false;
    }
}
```



### 2.2. Infinite Loop with Words

Given a array of words, can we form a circle such that each word starts with the same character that the last one ended on. The first word in the list will start with what the last word in the list ended on. For example

```
{“ALICE”, “CHARLES”, “ERIC”, “SOPHIA”} => {"ALICE", "ERIC", "CHARLES", "SOPHIA"} => true
```

**Answer**:

You're also familiar with how to solve this using N queen method. Here's how you could do swap permutation

```java
public class Solution {
    public boolean solve(String[] input) {
        return helper(input, 1);
    }
    
    private boolean helper(String[] input, int index) {
        if (index == input.length) {
            return isValid(input[index - 1], input[0]);
        }
        for (int i = index; i < input.length; i++) {
            if (isValid(input[index - 1], input[i])) {
                swap(input, index, i);
                if (helper(input, index + 1)) {
                    return true;
                }
                swap(input, index, i);
            }
        }
        return false;
    }
    
    private boolean isValid(String a, String b) {
        return a.charAt(a.length() - 1) == b.charAt(0);
    }
}
```



## 3. Splitting Numbers

### 3.1. Splitting Coins

Given a list of different coin types, find all possible ways of using these different types to make a certain amount. For example

```
target = 4 cents, coins = {2, 1}
Solution #1: 0 * 2 cents + 4 * 1 cent
Solution #2: 1 * 2 cents + 2 * 1 cent
Solution #3: 2 * 2 cents + 0 * 1 cent
```

**Answer**

```java
public class Solution {
    public List<List<Integer>> solve(int target, int[] coins) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> option = new ArrayList<>();
        helper(target, coins, 0, option, result);
        return result;
    }
    
    private void helper(int target, int[] coins, int index, List<Integer> option, List<List<Integer>> result) {
        if (index == coins.length) {
            if (remain == 0) {
                result.add(new ArrayList<Integer>(option));
            }
            return;
        }
        for (int i = 0; i * coins[index] <= target; i++) {
            option.add(i);
            helper(target - i * coins[index], coins, index + 1, option, result);
            option.remove(option.length() - 1);
        }
    }
}
```



### 3.2. Factor Combinations

Given an integer number, return all possible combinations of the factors that can multiply to the target number. For example

```
Given 24
since 24 = 2 x 2 x 2 x 3
         = 2 x 2 x 6
		 = 2 x 3 x 4
		 = 2 x 12
		 = 3 x 8
		 = 4 x 6
		 
your solution should return
{ { 2, 2, 2, 3 }, { 2, 2, 6 }, { 2, 3, 4 }, { 2, 12 }, { 3, 8 }, { 4, 6 } }
```



**Answer**:

```java
public class Solution {
    public List<List<Integer>> combinations(int target) {
        List<List<Integer>> result = new ArrayList<>();
        if (target <= 1) {
            return result;
        }
        List<Integer> cur = new ArrayList<>();
        List<Integer> factors = getFactors(target);
        helper(target, factors, 0, cur, result);
        return result;
    }
    
    private void helper(int target, List<Integer> factors, int index, List<Integer> cur, List<List<Integer>> result) {
        if (index == factors.size()) {
            if (target == 1) {
                result.add(new ArrayList<>(cur));
            }
            return;
        }
        helper(target, factors, index + 1, cur, result);
        int factor = factors.get(index);
        int size = cur.size();
        while (target % factor == 0) {
            cur.add(factor);
            target /= factor;
            helper(target, factors, index + 1, cur, result);
        }
        cur.subList(size, cur.size()).clear();
    }
    
    private List<Integer> getFactors(int target) {
        List<Integer> factors = new ArrayList<>();
        for (int i = target / 2; i > 1; i--) {
            if (target % i == 0) {
                factors.add(i);
            }
        }
        return factors;
    }
}
```







## 5. Longest String Chain

You are given an array of `words` where each word consists of lowercase English letters.

`wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly one** letter anywhere in `wordA` **without changing the order of the other characters** to make it equal to `wordB`.

- For example, `"abc"` is a **predecessor** of `"abac"`, while `"cba"` is not a **predecessor** of `"bcad"`.

A **word chain** is a sequence of words `[word1, word2, ..., wordk]` with `k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a **predecessor** of `word3`, and so on. A single word is trivially a **word chain** with `k == 1`.

Return *the **length** of the **longest possible word chain** with words chosen from the given list of* `words`.

 

**Example 1:**

```
Input: words = ["a","b","ba","bca","bda","bdca"]
Output: 4
Explanation: One of the longest word chains is ["a","ba","bda","bdca"].
```

**Example 2:**

```
Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
Output: 5
Explanation: All the words can be put in a word chain ["xb", "xbc", "cxbc", "pcxbc", "pcxbcf"].
```

**Example 3:**

```
Input: words = ["abcd","dbqca"]
Output: 1
Explanation: The trivial word chain ["abcd"] is one of the longest word chains.
["abcd","dbqca"] is not a valid word chain because the ordering of the letters is changed.
```

 **Solution**

```java
class Solution {
    // TC = O(N(L^2))
    // SC = O(N)
    public int longestStrChain(String[] words) {
        Map<String, Integer> memo = new HashMap<>();
        Set<String> wordSet = new HashSet<>();
        Collections.addAll(wordSet, words);
        int result = 0;
        for (String word : words) {
            result = Math.max(result, helper(wordSet, memo, word));
        }
        return result;
    }
    
    private int helper(Set<String> words, Map<String, Integer> memo, String cur) {
        if (memo.containsKey(cur)) {
            return memo.get(cur);
        }
        
        int maxLength = 1;
        StringBuilder str = new StringBuilder(cur);
        for (int i = 0; i < cur.length(); i++) {
            str.deleteCharAt(i);
            String newWord = str.toString();
            if (words.contains(newWord)) {
                int currentLength = 1 + helper(words, memo, newWord);
                maxLength = Math.max(maxLength, currentLength);
            }
            str.insert(i, cur.charAt(i));
        }
        memo.put(cur, maxLength);
        return maxLength;
    }
}
```





## 6.  Sliding Puzzle

On an `2 x 3` board, there are five tiles labeled from `1` to `5`, and an empty square represented by `0`. A **move** consists of choosing `0` and a 4-directionally adjacent number and swapping it.

The state of the board is solved if and only if the board is `[[1,2,3],[4,5,0]]`.

Given the puzzle board `board`, return *the least number of moves required so that the state of the board is solved*. If it is impossible for the state of the board to be solved, return `-1`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg)

```
Input: board = [[1,2,3],[4,0,5]]
Output: 1
Explanation: Swap the 0 and the 5 in one move.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg)

```
Input: board = [[1,2,3],[5,4,0]]
Output: -1
Explanation: No number of moves will make the board solved.
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg)

```
Input: board = [[4,1,2],[5,0,3]]
Output: 5
Explanation: 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
```

**DFS Solution**

```java
class Solution {
    
    public int slidingPuzzle(int[][] board) {
        StringBuilder str = new StringBuilder();
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				str.append(board[i][j]);
			}
		}
		Map<String, Integer> seen = new HashMap<>();
		// 0 1 2
		// 3 4 5
		final int[][] swaps = { { 1, 3 }, { 0, 2, 4 }, { 1, 5 }, { 0, 4 }, { 1, 3, 5 }, { 2, 4 } };

		int[] min = { Integer.MAX_VALUE };
		int index = 0;
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '0') {
				index = i;
				break;
			}
		}

		helper(str, index, 0, swaps, seen, min);
		return min[0] == Integer.MAX_VALUE ? -1 : min[0];
    }
    
    private void helper(StringBuilder sb, int index, int step, int[][] swaps, Map<String, Integer> seen,
			int[] min) {
		String str = sb.toString();
		if (str.equals("123450")) {
			min[0] = Math.min(min[0], step);
			return;
		}
		if (seen.containsKey(str)) {
			if (step >= seen.get(str)) {
				return;
			}
		}
		seen.put(str, step);
		for (int nextIdx : swaps[index]) {
			swap(sb, index, nextIdx);
			helper(sb, nextIdx, step + 1, swaps, seen, min);
			swap(sb, index, nextIdx);
		}
	}
    
    private void swap(StringBuilder str, int i, int j) {
		char temp = str.charAt(i);
		str.setCharAt(i, str.charAt(j));
		str.setCharAt(j, temp);
	}
}
```



# DP

## 1. Largest Sub-Matrix Sum

Given a matrix that contains integers, find the submatrix with the largest sum.

Return the sum of the submatrix.

**Assumptions**

- The given matrix is not null and has size of M * N, where M >= 1 and N >= 1

**Examples**

{ {1, -2, **-1, 4**},

 {1, -1,  **1, 1**},

 {0, -1, **-1, 1**},

 {0,  0,  **1, 1**} }

the largest submatrix sum is (-1) + 4 + 1 + 1 + (-1) + 1 + 1 + 1 = 7.

**Answer**

```java
public class Solution {
    public int largest(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int result = Integer.MIN_VALUE;
        
        for (int i = 0; i < m; i++) {
            int[] cur = new int[n];
            for (int j = i; j < m; j++) {
                add(cur, matrix[j]);
                result = Math.max(result, max(cur));
            }
        }
        return result;
    }
    
    private void add(int[] cur, int[] add) {
        for (int i = 0; i < cur.length; i++) {
            cur[i] += add[i];
        }
    }
    
    private int max(int[] cur) {
        int result = cur[0];
        int tmp = cur[0];
        for (int i = 1; i < cur.length; i++) {
            tmp = Math.max(tmp + cur[i], cur[i]);
            result = Math.max(result, tmp);
        }
        return result;
    }
    
    // TC = O(m * n * n)
    // SC = O(m * n)
}
```



## 2. Largest Set Of Points With Positive Slope



Given an array of 2D coordinates of points (all the coordinates are integers), find the largest number of points that can form a set such that any pair of points in the set can form a line with positive slope. Return the size of such a maximal set.

**Assumptions**

- The given array is not null
- **Note**: if there does not even exist 2 points can form a line with positive slope, should return 0.

**Examples**

- <0, 0>, <1, 1>, <2, 3>, <3, 3>, the maximum set of points are {<0, 0>, <1, 1>, <2, 3>}, the size is 3.

**Answer**

```java
/*
* class Point {
*   public int x;
*   public int y;
*   public Point(int x, int y) {
*     this.x = x;
*     this.y = y;
*   }
* }
*/
public class Solution {
    public int largest(Point[] points) {
        Arrays.sort(points, new MyComparator());
        int result = 0;
        int[] longest = new int[points.length];
        for (int i = 0; i < longest.length; i++) {
            for (int j = 0; j < i; j++) {
                if (points[j].y < points[i].y) {
                    longest[i] = Math.max(longest[i], longest[j]);
                }
            }
            longest[i]++;
            result = Math.max(result, longest[i]);
        }
        return result == 1 ? 0 : result;
    }
    
    static class MyComparator implements Comparator<Point> {
        @Override
        public int compare(Point p1, Point p2) {
            return p1.x != p2.x ? p1.x - p2.x : p2.y - p1.y;
        }
    }
}
```



## 3. Largest X Of 1s

Given a matrix that contains only 1s and 0s, find the largest X shape which contains only 1s, with the same arm lengths and the four arms joining at the central point.

Return the arm length of the largest X shape.

**Assumptions**

- The given matrix is not null, has size of N * M, N >= 0 and M >= 0.

**Examples**

{ {0, 0, 0, 0},

 {**1**, 1, **1**, 1},

 {0, **1**, 1, 1},

 {**1**, 0, **1**, 1} }

the largest X of 1s has arm length 2.

**Answer**

```java
public class Solution {
    public int largest(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int N = matrix.length;
        int M = matrix[0].length;
        int[][] leftUp = leftUp(matrix, N, M);
        int[][] rightDown = rightDown(matrix, N, M);
        return merge(leftUp, rightDown, N, M);
    }
    
    private int merge(int[][] leftUp, int[][] rightDown, int N, int M) {
        int result = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                leftUp[i][j] = Math.min(leftUp[i][j], rightDown[i][j]);
                result = Math.max(result, leftUp[i][j]);
            }
        }
        return result;
    }
    
    private int[][] leftUp(int[][] matrix, int N, int M) {
        int[][] left = new int[N][M];
        int[][] up = new int[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (matrix[i][j] == 1) {
                    left[i][j] = getNumber(left, i - 1, j - 1, N, M) + 1;
                    up[i][j] = getNumber(up, i - 1, j + 1, N, M) + 1;
                }
            }
        }
        merge(left, up, N, M);
        return left;
    }
    
    private int[][] rightDown(int[][] matrix, int N, int M) {
        int[][] right = new int[N][M];
        int[][] down = new int[N][M];
        for (int i = N - 1; i >= 0; i--) {
            for (int j = M - 1; j >= 0; j--) {
                if (matrix[i][j] == 1) {
                    right[i][j] = getNumber(right, i + 1, j + 1, N, M) + 1;
                    down[i][j] = getNumber(down, i + 1, j - 1, N, M) + 1;
                }
            }
        }
        merge(right, down, N, M);
        return right;
    }
    
    private int getNumber(int[][] number, int x, int y, int N, int M) {
        if (x < 0 || x >= N || y < 0 || y >= M) {
            return 0;
        }
        return number[x][y];
    }
}
```



## 4. Pascal's Triangle II

Given an integer N, return the N-th row of the **Pascal's triangle**:

```
1th                 1
2rd               1   1
3rd             1   2   1
4th           1   3   3   1
5th         1   4   6   4   1
...
```

**Examples**

```
Input: N = 3  =>  Output: [1,3,3,1]
Input: N = 0  =>  Output: [1]
Input: N = 1  =>  Output: [1,1]
```

**Answer**

```java
public class Solution {
    // TC = O(N^2)
    // SC = O(N)
	public List<Integer> getRow(int n) {
        Integer[] dp = new Integer[n + 1];
        Arrays.fill(dp, 0);
        for (int i = 1; i <= n; i++) {
            for (int j = i; j > 0; j--) {
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return Arrays.asList(dp);
    }
}
```



## 5. Maximum Profit in Job Scheduling

We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.

 

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png)**

```
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png)**

```
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.
```

**Example 3:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png)**

```
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6
```



**Solution**

```java
class Solution {
    // maximum number of jobs are 50000
    int[] memo = new int[50001];
    
    private int findNextJob(int[] startTime, int lastEndingTime) {
        int start = 0, end = startTime.length - 1, nextIndex = startTime.length;
        
        while (start <= end) {
            int mid = (start + end) / 2;
            if (startTime[mid] >= lastEndingTime) {
                nextIndex = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return nextIndex;
    }
    
    private int findMaxProfit(List<List<Integer>> jobs, int[] startTime, int n, int position) {
        // 0 profit if we have already iterated over all the jobs
        if (position == n) {
            return 0;
        }
        
        // return result directly if it's calculated 
        if (memo[position] != -1) {
            return memo[position];
        }
        
        // nextIndex is the index of next non-conflicting job
        int nextIndex = findNextJob(startTime, jobs.get(position).get(1));
        
        // find the maximum profit of our two options: skipping or scheduling the current job
        int maxProfit = Math.max(findMaxProfit(jobs, startTime, n, position + 1), 
                        jobs.get(position).get(2) + findMaxProfit(jobs, startTime, n, nextIndex));
        
        // return maximum profit and also store it for future reference (memoization)
        return memo[position] = maxProfit;
    }
    
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        List<List<Integer>> jobs = new ArrayList<>();
        
        // marking all values to -1 so that we can differentiate 
        // if we have already calculated the answer or not
        Arrays.fill(memo, -1);
        
        // storing job's details into one list 
        // this will help in sorting the jobs while maintaining the other parameters
        int length = profit.length;
        for (int i = 0; i < length; i++) {
            ArrayList<Integer> currJob = new ArrayList<>();
            currJob.add(startTime[i]);
            currJob.add(endTime[i]);
            currJob.add(profit[i]);
            jobs.add(currJob);
        }
        jobs.sort(Comparator.comparingInt(a -> a.get(0)));
        
        // binary search will be used in startTime so store it as separate list
        for (int i = 0; i < length; i++) {
            startTime[i] = jobs.get(i).get(0);
        }
  
        return findMaxProfit(jobs, startTime, length, 0);
    }
}
```



## 6. Best Time to Buy and Sell Stock

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return *the maximum profit you can achieve from this transaction*. If you cannot achieve any profit, return `0`.

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

**Example 2:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

**Solution**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for (int i = 0; i < prices.length; i++) {
            min = Math.min(prices[i], min);
            max = Math.max(prices[i] - min, max);
        }
        return max;
    }
}
```



## 7. Dungeon Game

he demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.

Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).

To reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.

Return *the knight's minimum initial health so that he can rescue the princess*.

**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg)

```
Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
Output: 7
Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.
```

**Example 2:**

```
Input: dungeon = [[0]]
Output: 1
```

**Solution**

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        
        final int M = dungeon.length;
        final int N = dungeon[0].length;
        
        int[][] dp = new int[M][N];
        dp[M - 1][N - 1] = dungeon[M - 1][N - 1] > 0 ? 1 : -dungeon[M - 1][N - 1] + 1;

        
        for (int i = M - 1; i >= 0; i--) {
            for (int j = N - 1; j >= 0; j--) {
                if (i == M - 1 && j != N - 1) {
                    dp[i][j] = getNext(dungeon[i][j], dp[i][j + 1]);
                } else if (i != M - 1 && j == N - 1) {
                    dp[i][j] = getNext(dungeon[i][j], dp[i + 1][j]);
                } else if (i != M - 1 && j != N - 1) {
                    int right = getNext(dungeon[i][j], dp[i][j + 1]); 
                    int down = getNext(dungeon[i][j], dp[i + 1][j]);
                    dp[i][j] = Math.min(right, down);
                }
            }
        }
        return dp[0][0];
    }
    
    private int getNext(int thisCell, int nextReq) {
        int diff = thisCell - nextReq;
        if (diff < 0) {
            return -diff;
        } else {
            return 1;
        }
    }
}
```



## 8. Max Rectangle in Histogram

Given a non-negative integer array representing the heights of a list of adjacent bars. Suppose each bar has a width of 1. Find the largest rectangular area that can be formed in the histogram.

**Assumptions**

- The given array is not null or empty

**Examples**

- { 2, 1, **3, 3, 4** }, the largest rectangle area is 3 * 3 = 9(starting from index 2 and ending at index 4)

**Solution #1 w DP** 

```java
// Meaning of M[i]: max area of rectangle with i as left edge
// For each i, M[i] = max(h * (j - i + 1)) for i <= j < N, where h = min(M[j])
// TC = O(N^2)
// SC = O(N)
public class Solution {
    public int largest(int[] array) {
        int[] M = new int[array.length];
        int max = 0;
        for (int i = 0; i < M.length; i++) {
            int height = array[i];
            for (int j = i; j < M.length; j++) {
                height = Math.min(height, array[j]);
                int width = j - i + 1;
                M[i] = Math.max(height * width, M[i]);
            }
            max = Math.max(M[i], max);
        }
        return max;
    }
}
```



**Solution #2**

```java
// TC = O(N)
// SC = O(N)
public class Solution {
    public int largest(int[] array) {
        int result = 0;
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i <= array.length; i++) {
            int cur = i == array.length ? 0 : array[i];
            while (!stack.isEmpty() && array[stack.peekFirst()] >= cur) {
                int height = array[stack.pollFirst()];
                int left = stack.isEmpty() ? 0 : stack.peekFirst() + 1;
                result = Math.max(result, height * (i - left));
            }
            stack.offerFirst(i);
        }
        return result;
    }
}
```



## 9. Burst Balloons

You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.

If you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.

Return *the maximum coins you can collect by bursting the balloons wisely*.

**Example 1:**

```
Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```

**Example 2:**

```
Input: nums = [1,5]
Output: 10
```

**Solution**

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length + 2;
        int[] newNums = new int[n];
        System.arraycopy(nums, 0, newNums, 1, n - 2);
        newNums[0] = 1;
        newNums[n - 1] = 1;
        
        int[][] memo = new int[n][n];
        return dp(memo, newNums, 1, n - 2);
    }
    
    public int dp(int[][] memo, int[] nums, int left, int right) {
        if (right - left < 0) {
            return 0;
        }
        
        if (memo[left][right] > 0) {
            return memo[left][right];
        }
        
        int result = 0;
        for (int i = left; i <= right; i++) {
            int gain = nums[left - 1] * nums[i] * nums[right + 1];
            int remaining = dp(memo, nums, left, i - 1) + dp(memo, nums, i + 1, right);
            result = Math.max(result, remaining + gain);
        }
        
        memo[left][right] = result;
        return result;
    }
} 
```



## 10. Array Hopper Variants

### 10.1. Jump Game II

Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [2,3,0,1,4]
Output: 2
```

**Solution**

```java
public int jump(int[] nums) {
	int len = nums.length;
	int[] dp = new int[len];
	Arrays.fill(dp, len + 1);
	dp[0] = 0;
	for (int i = 0; i < len; i++) {
		int start = i;
		int end = Math.min(i + nums[i], len - 1);
		for (int j = start; j <= end; j++) {
			dp[j] = Math.min(dp[j], dp[start] + 1);
		}
	}
	return dp[len - 1] == len + 1 ? -1 : dp[len - 1];
}
```



### 10.2. Video Stitching

You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.

Each video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.

We can cut these clips into segments freely.

- For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.

Return *the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event* `[0, time]`. If the task is impossible, return `-1`.

**Example 1:**

```
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10
Output: 3
Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
```

**Example 2:**

```
Input: clips = [[0,1],[1,2]], time = 5
Output: -1
Explanation: We cannot cover [0,5] with only [0,1] and [1,2].
```

**Example 3:**

```
Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9
Output: 3
Explanation: We can take clips [0,4], [4,7], and [6,9].
```

**Solution**

```java
public int videoStitching(int[][] clips, int T) {
	int[] dp = new int[T + 1];
	Arrays.fill(dp, T + 2);
	dp[0] = 0;

	for (int i = 0; i <= T; i++) {
		for (int[] clip : clips) {
			int start = clip[0];
			int end = clip[1];
			if (i >= start && i <= end)
				dp[i] = Math.min(dp[i], dp[start] + 1);
		}
	}
	return dp[T] == T + 2 ? -1 : dp[T];
}
```



### 10.3. Minimum Number of Taps to Open to Water a Garden

There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).

There are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.

Given an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.

Return *the minimum number of taps* that should be open to water the whole garden, If the garden cannot be watered return **-1**.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png)

```
Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
Explanation: The tap at point 0 can cover the interval [-3,3]
The tap at point 1 can cover the interval [-3,5]
The tap at point 2 can cover the interval [1,3]
The tap at point 3 can cover the interval [2,4]
The tap at point 4 can cover the interval [4,4]
The tap at point 5 can cover the interval [5,5]
Opening Only the second tap will water the whole garden [0,5]
```

**Example 2:**

```
Input: n = 3, ranges = [0,0,0,0]
Output: -1
Explanation: Even if you activate all the four taps you cannot water the whole garden.
```

**Solution**

```java
class Solution {
    public int minTaps(int n, int[] ranges) {
        int[] M = new int[ranges.length];
        Arrays.fill(M, M.length + 1);
        M[0] = 0;
        
        for (int i = 0; i < M.length; i++) {
            if (ranges[i] != 0) {
                int start = Math.max(i - ranges[i], 0);
                int end = Math.min(i + ranges[i], M.length - 1);
                for (int j = start; j <= end; j++) {
                    M[j] = Math.min(M[j], M[start] + 1);
                }
            }
        }
        return M[M.length - 1] == M.length + 1 ? -1 : M[M.length - 1]; 
    }
}
```



### 10.4. Minimum Number of Refueling Stops

A car travels from a starting position to a destination which is `target` miles east of the starting position.

There are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.

The car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.

Return *the minimum number of refueling stops the car must make in order to reach its destination*. If it cannot reach the destination, return `-1`.

Note that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.

 

**Example 1:**

```
Input: target = 1, startFuel = 1, stations = []
Output: 0
Explanation: We can reach the target without refueling.
```

**Example 2:**

```
Input: target = 100, startFuel = 1, stations = [[10,100]]
Output: -1
Explanation: We can not reach the target (or even the first gas station).
```

**Example 3:**

```
Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
Output: 2
Explanation: We start with 10 liters of fuel.
We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.
Then, we drive from position 10 to position 60 (expending 50 liters of fuel),
and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.
We made 2 refueling stops along the way, so we return 2.
```

**Solution**

```java
class Solution {
    public int minRefuelStops(int target, int startFuel, int[][] stations) {        
        final int N = stations.length;
        int[] dp = new int[N + 1];
        dp[0] = startFuel;
        for (int i = 0; i < N; i++) {
            for (int j = i; j >= 0; j--) {
                if (dp[j] >= stations[i][0]) {
                    dp[j + 1] = Math.max(dp[j + 1], dp[j] + stations[i][1]);
                }
            }
        }
        for (int i = 0; i <= N; i++) {
            if (dp[i] >= target) {
                return i;
            }
        }
        return -1;
    }
}
```



## 11. Frog Jump

A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.

Given a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.

If the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.

 

**Example 1:**

```
Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.
```

**Example 2:**

```
Input: stones = [0,1,2,3,4,8,9,11]
Output: false
Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.
```

 **Solution**

```java
class Solution {
    //
    //            1k=1
    //          /   |    \
    //        X     X     3k=2
    //               /     |             \
    //              X     5k=2                   6k=3 
    //                 /   |   \              /    |     \
    //               6k=1  x   8k=3        8k=2    X      X
    //           /  |  \      /| \         /|\     
    //          X   X  8k=2  X X 12k=4    X X X       
    //                         /   |   \
    //                        x    x   17k=5 
    //
    // DFS Solution
    // TC = O(3^N)
    // SC = O(N)
    // 
    // DP Solution
    //      i
    //   0  1  3  5  6  8  12 17
    // k 0  1  2  2  3  3  4  5
    //               1  2
    //
    // TC = O(N^2)
    // SC = O(N^2)
    
    public boolean canCross(int[] stones) {
        Map<Integer, Set<Integer>> map = new HashMap<>();
        for (int i = 0; i < stones.length; i++) {
            map.put(stones[i], new HashSet<Integer>());
        }
        map.get(0).add(0);
        for (int i = 0; i < stones.length; i++) {
            for (int k : map.get(stones[i])) {
                for (int step = k - 1; step <= k + 1; step++) {
                    if (step > 0 && map.containsKey(stones[i] + step)) {
                        map.get(stones[i] + step).add(step);
                    }
                }
            }
        }
        return map.get(stones[stones.length - 1]).size() > 0;
    }
}
```



# Probability, Sampling & Randomization

## 1. Perfect Shuffle

Given an array of integers (without any duplicates), shuffle the array such that all permutations are equally likely to be generated.

**Assumptions**

- The given array is not null

**Answer**

```java
public class Solution {
    public void shuffle(int[] array) {
        if (array.length <= 1) {
            return;
        }
        
        for (int i = 0; i < array.length; i++) {
            int index = (int)(Math.random() * (array.length - 1));
            swap(array, i, index);
        }
    }
    
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```



## 2. Reservoir Sampling

Consider an unlimited flow of data elements. How do you sample one element from this flow, such that at any point during the processing of the flow, you can return a random element from the n elements read so far.

You will implement two methods for a sampling class:

- read(int value) - read one number from the flow
- sample() - return at any time the sample, if n values have been read, the probability of returning any one of the n values is 1/n, return null if there is no value read so far

You may need to add more fields for the class.

**Answer**

```java
public class Solution {
    private int count;
    private Integer sample;
    
    public Solution() {
        this.count = 0;
        this.sample = null;
    }
    
    public void read(int value) {
        count++;
        int prob = (int) (Math.random() * count);
        if (prob == 0) {
            this.sample = value;
        }
    }
    
    public Integer sample() {
        return sample;
    }
}
```



## 3. Insert Delete Get Random O(1)

Implement the `RandomizedSet` class:

- `RandomizedSet()` Initializes the `RandomizedSet` object.
- `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
- `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

**Example 1:**

```
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
```

**Solution**

```java
class RandomizedSet {
    
    private Map<Integer, Integer> map;
    private List<Integer> list;
    
    public RandomizedSet() {
        map = new HashMap<>();
        list = new ArrayList<>();
    }
    
    public boolean insert(int val) {
        if (map.containsKey(val)) {
            return false;
        }
        map.put(val, list.size());
        list.add(val);
        return true;
    }
    
    public boolean remove(int val) {
        if (!map.containsKey(val)) {
            return false;
        }
        int lastElement = list.get(list.size() - 1);
        int idx = map.get(val);
        list.set(idx, lastElement);
        map.put(lastElement, idx);
        list.remove(list.size() - 1);
        map.remove(val);
        return true;
    }
    
    public int getRandom() {
        int index = (int)(Math.random() * list.size());
        return list.get(index);
    }
}
```





# Trie

<img src="C:\Users\EddyM\Desktop\KnowledgeBase\Assets\Trie-1.jpg" alt="Trie-1" style="zoom:70%;" />

Here is a trie that is storing the following data:

```json
trie = {
    "" : 1,
    "at" : 2,
    "app" : 3,
    "apple" : 4,
    "cap" : 5,
    "cat" : 6,
    "cathy" : 7,
    "dog" : 8,
}
```

Unlike other data structures, trie has the advantage of guaranteed TC = O(string length) on search, add, delete operations. 

## 1. Implementation

```java
class TrieNode {
    int count;  // # of words, aka red nodes, in this subtree (inclusive)
    Map<Character, TrieNode> children;
    boolean isWord;
    int value;  // optional. Could be a set w/o this field
}

public boolean search(String word) {
    TrieNode cur = root;
    for (int i = 0; i < word.length(); i++) {
        TrieNode next = cur.children.get(word.charAt(i));
        if (next == null) {
            return false;
        }
        cur = next;
    }
    return cur.isWord;
}

public boolean insert(String word) {
    if (search(word)) {
        return false;
    }
    TrieNode cur = root;
    for (int i = 0; i < word.length(); i++) {
        TrieNode next = cur.children.get(word.charAt(i));
        if (next == null) {
            next = new TrieNode();
            cur.children.put(word.charAt(i), next);
        }
        cur = next;
        cur.count++;
    }
    cur.isWord = true;
    return true;
}

public boolean delete(String word) {
    if (!search(word)) {
        return false;
    }
    TrieNode cur = root;
    for (int i = 0; i < word.length(); i++) {
        TrieNode next = cur.children.get(word.charAt(i));
        next.count--;
        if (next.count == 0) {
            cur.children.remove(word.charAt(i));
            return true;
        }
        cur = next;
    }
    cur.isWord = false;
    return true;
}
```



## 2. Word Search II

Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*.

Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

```
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

```
Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
```

**Solution**

```java
class Solution {
    
    // TC = O(4^(m*n))
    // SC = O(m*n)
    
    static final int[][] DIRS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public List<String> findWords(char[][] board, String[] words) {
        
        int m = board.length;
        int n = board[0].length;
        
        if (m == 0 || n == 0 || words.length == 0) {
            return new ArrayList<>();
        }
        Set<String> res = new HashSet<>();
        TrieNode root = buildDict(words);
        boolean[][] visited = new boolean[m][n];
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                helper(board, i, j, root, str, res, visited);
            }
        }
        return new ArrayList<>(res);
    }
    
    private void helper(char[][] board, int x, int y, TrieNode root, StringBuilder str, Set<String> res, boolean[][] visited) {
        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y]) {
            return;
        }
        
        char cur = board[x][y];
        if (root.children.get(cur) == null) {
            return;
        }
        str.append(cur);
        root = root.children.get(cur);
        if (root.isWord) {
            res.add(str.toString());
        }
        visited[x][y] = true;
        for (int[] dir : DIRS) {
            int neiX = dir[0] + x;
            int neiY = dir[1] + y;
            helper(board, neiX, neiY, root, str, res, visited);
        }
        visited[x][y] = false;
        str.deleteCharAt(str.length() - 1);
    }
    
    private TrieNode buildDict(String[] words) {
        TrieNode root = new TrieNode();
        for (String word : words) {
            TrieNode cur = root;
            for (int i = 0; i < word.length(); i++) {
                TrieNode next = cur.children.get(word.charAt(i));
                if (next == null) {
                    next = new TrieNode();
                    cur.children.put(word.charAt(i), next);
                }
                cur = next;
            }
            cur.isWord = true;
        }
        return root;
    }
}

class TrieNode {
    public Map<Character, TrieNode> children;
    public boolean isWord;
    
    public TrieNode() {
        this.children = new HashMap<Character, TrieNode>();
        this.isWord = false;
    }
}
```



# Arrays

## 1. Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Solution**

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        
        // Sort interval by their start value
        // Lambda Notation ?
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        // When return size uncertain, use a fucking list
        LinkedList<int[]> merged = new LinkedList<>();
        
        for (int[] interval : intervals) {
            if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {
                merged.add(interval);
            } else {
                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```

**Note** Lambda Notation

It's like what they do in JavaScript: https://www.w3schools.com/java/java_lambda.asp

```java
List<Integer> numbers = new ArrayList<>();
...
numbers.forEach( (n) -> {System.out.println(n); } );
```



## 2. Meeting Rooms II

Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return *the minimum number of conference rooms required*.

**Example 1**

```
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2
```

**Example 2**

```
Input: intervals = [[7,10],[2,4]]
Output: 1
```

**Solution 1**

```java
class Solution {
    // TC = O(NlogN)
    // SC = O(N)
    public int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        
        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(
            intervals.length,
            new Comparator<Integer>() {
                @Override
                public int compare(Integer a, Integer b) {
                    return a - b;
                }
            }
        );
        
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(final int[] a, final int[] b) {
                return a[0] - b[0];
            }
        });
        
        minHeap.add(intervals[0][1]);
        
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= minHeap.peek()) {
                minHeap.poll();
            }
            minHeap.add(intervals[i][1]);
        }
        
        return minHeap.size();
    }
}
```

**Solution 2**

```java
class Solution {
    // TC = O(NlogN)
    // SC = O(N)
    public int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        
        Integer[] start = new Integer[intervals.length];
        Integer[] end = new Integer[intervals.length];
        
        for (int i = 0; i < intervals.length; i++) {
            start[i] = intervals[i][0];
            end[i] = intervals[i][1];
        }
        
        Arrays.sort(
            end,
            new Comparator<Integer>() {
                public int compare(Integer a, Integer b) {
                    return a - b;
                }
            });
        
        Arrays.sort(
            start,
            new Comparator<Integer>() {
                public int compare(Integer a, Integer b) {
                    return a - b;
                }
            });
        
        int startPointer = 0, endPointer = 0;
        int usedRooms = 0;
        while (startPointer < intervals.length) {
            if (start[startPointer] >= end[endPointer]) {
                usedRooms -= 1;
                endPointer += 1;
            }
            usedRooms += 1;
            startPointer += 1;
        }
        return usedRooms;
    }
}
```



## 3. Next Permutation

A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.

- For example, for `arr = [1,2,3]`, the following are considered permutations of `arr`: `[1,2,3]`, `[1,3,2]`, `[3,1,2]`, `[2,3,1]`.

The **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.
- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.
- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.

Given an array of integers `nums`, *find the next permutation of* `nums`.

The replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.

**Example 1:**

```
Input: nums = [1,2,3]
Output: [1,3,2]
```

**Example 2:**

```
Input: nums = [3,2,1]
Output: [1,2,3]
```

**Example 3:**

```
Input: nums = [1,1,5]
Output: [1,5,1]
```

**Solution**

![31_Next_Permutation](C:\Users\EddyM\Desktop\KnowledgeBase\Assets\31_Next_Permutation.gif)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }
    
    private void reverse(int[] nums, int start) {
        int i = start;
        int j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }
    
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```



## 4. 3 Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```
Input: nums = []
Output: []
```

**Example 3:**

```
Input: nums = [0]
Output: []
```

**Solution**

```java
class Solution {
    
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length && nums[i] <= 0; i++) {
            if (i == 0 || nums[i - 1] != nums[i]) {
                helper(nums, i, res);
            }
        }
        return res;
    }
    
    private void helper(int[] nums, int i, List<List<Integer>> res) {
        int left = i + 1;
        int right = nums.length - 1;
        
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum < 0) {
                left++;
            } else if (sum > 0) {
                right--;
            } else {
                res.add(Arrays.asList(nums[i], nums[left++], nums[right--]));
                while (right < left && nums[left] == nums[left - 1]) {
                    left++;
                }
            }
        }
    }
}
```



## 5. First Missing Positive

Given an unsorted integer array `nums`, return the smallest missing positive integer.

You must implement an algorithm that runs in `O(n)` time and uses constant extra space.

**Example 1:**

```
Input: nums = [1,2,0]
Output: 3
```

**Example 2:**

```
Input: nums = [3,4,-1,1]
Output: 2
```

**Example 3:**

```
Input: nums = [7,8,9,11,12]
Output: 1
```

**Solution**

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        
        boolean contains = false;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                contains = true;
                break;
            }
        }
        
        if (!contains) {
            return 1;
        }
        
        for (int i = 0; i < n; i++) {
            if ( nums[i] <= 0 || nums[i] > n) {
                nums[i] = 1;
            }
        }
        
        for (int i = 0; i < n; i++) {
            int a = Math.abs(nums[i]);
            if (a == n) {
                nums[0] = - Math.abs(nums[0]);
            } else {
                nums[a] = - Math.abs(nums[a]);
            }
        }
        
        for (int i = 1; i < n; i++) {
            if (nums[i] > 0) {
                return i;
            }
        }
        
        if (nums[0] > 0) {
            return n;
        }
        
        return n + 1;
    }
}
```



## 6. Sliding Window Maximum

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return *the max sliding window*.

 

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

**Solution**

```java
class Solution {
    public int[] maxSlidingWindow(int[] array, int k) {
        int[] result = new int[array.length - k + 1];
        int index = 0;
        
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < array.length; i++) {
            while (!deque.isEmpty() && array[deque.peekLast()] <= array[i]) {
                deque.pollLast();
            }
            
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            
            deque.offerLast(i);
            if (i >= k - 1) {
                result[index] = array[deque.peekFirst()];
                index += 1;
            }
        }
        return result;
    }
}
```



## 7. Spiral Matrix

Given an `m x n` `matrix`, return *all elements of the* `matrix` *in spiral order*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Solution**

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        
        int up = 0;
        int down = matrix.length - 1;
        int left = 0;
        int right = matrix[0].length - 1;
       
        while (up < down && left < right) {
            for (int i = left; i < right; i++) {
                result.add(matrix[up][i]);
            }
            for (int i = up; i < down; i++) {
                result.add(matrix[i][right]);
            }
            for (int i = right; i > left; i--) {
                result.add(matrix[down][i]);
            }
            for (int i = down; i > up; i--) {
                result.add(matrix[i][left]);
            }
            left++;
            up++;
            right--;
            down--;
        }
        
        if (up > down || left > right) {
            return result;
        }
        
        if (left == right) {
            for (int i = up; i <= down; i++) {
                result.add(matrix[i][left]);
            }
        } else {
            for (int i = left; i <= right; i++) {
                result.add(matrix[up][i]);
            }
        }
        return result;
    }
}
```



## 8. Employee Free Time

We are given a list `schedule` of employees, which represents the working time for each employee.

Each employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order.

Return the list of finite intervals representing **common, positive-length free time** for *all* employees, also in sorted order.

(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined). Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.

**Example 1:**

```
Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
Output: [[3,4]]
Explanation: There are a total of three employees, and all common
free time intervals would be [-inf, 1], [3, 4], [10, inf].
We discard any intervals that contain inf as they aren't finite.
```

**Example 2:**

```
Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]
```

 **Solution**

```java
/*
// Definition for an Interval.
class Interval {
    public int start;
    public int end;

    public Interval() {}

    public Interval(int _start, int _end) {
        start = _start;
        end = _end;
    }
};
*/

class Solution {
    public List<Interval> employeeFreeTime(List<List<Interval>> schedule) {
        //  
        // prev = 7
        //
        // [1 3] [6 7] 
        //             ^
        // [2 4]
        //        ^
        // [2 5] [9 12] 
        //              ^
        //
        // List = [[5 6] [7 9]]
        
        final int K = schedule.size();
        
        PriorityQueue<Cell> minHeap = new PriorityQueue<>(K, new Comparator<Cell>(){
            @Override
            public int compare(Cell a, Cell b) {
                return a.interval.start - b.interval.start;
            }
        });
        
        for (int i = 0; i < K; i++) {
            minHeap.offer(new Cell(schedule.get(i).get(0), i, 0));
        }
        
        List<Interval> result = new ArrayList<>();
        int prev = Integer.MIN_VALUE;
        
        while (!minHeap.isEmpty()) {
            Cell cur = minHeap.poll();
            
            if (cur.interval.start > prev) {
                result.add(new Interval(prev, cur.interval.start));
            }
            prev = Math.max(cur.interval.end, prev);
            if (cur.index + 1 < schedule.get(cur.array).size()) {
                minHeap.offer(new Cell(schedule.get(cur.array).get(cur.index + 1), cur.array, cur.index + 1));
            }
        }
        result.remove(0);
        
        return result;
    }
}

class Cell {
    public Interval interval;
    public int array;
    public int index;
    public Cell(Interval interval, int array, int index) {
        this.interval = interval;
        this.array = array;
        this.index = index;
    }
}
```





# TikTok

You have solved **44 / 82** problems.

Show problem tags

Select time period:6 months

|      | #    | Title                                                        | Acceptance | Difficulty | Frequency |
| ---- | ---- | ------------------------------------------------------------ | ---------- | ---------- | --------- |
|      | 5    | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring) | 31.7%      | **Medium** |           |
|      | 12   | [Integer to Roman](https://leetcode.com/problems/integer-to-roman) | 59.1%      | **Medium** |           |
|      | 13   | [Roman to Integer](https://leetcode.com/problems/roman-to-integer) | 57.9%      | **Easy**   |           |
|      | 15   | [3Sum](https://leetcode.com/problems/3sum)                   | 30.7%      | **Medium** |           |
|      | 20   | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses) | 40.6%      | **Easy**   |           |
|      | 23   | [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists) | 46.5%      | **Hard**   |           |
|      | 31   | [Next Permutation](https://leetcode.com/problems/next-permutation) | 35.3%      | **Medium** |           |
|      | 33   | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array) | 37.5%      | **Medium** |           |
|      | 35   | [Search Insert Position](https://leetcode.com/problems/search-insert-position) | 42.5%      | **Easy**   |           |
|      | 37   | [Sudoku Solver](https://leetcode.com/problems/sudoku-solver) | 53.1%      | **Hard**   |           |
|      | 45   | [Jump Game II](https://leetcode.com/problems/jump-game-ii)   | 36.5%      | **Medium** |           |
|      | 50   | [Pow(x, n)](https://leetcode.com/problems/powx-n)            | 32.1%      | **Medium** |           |
|      | 54   | [Spiral Matrix](https://leetcode.com/problems/spiral-matrix) | 40.6%      | **Medium** |           |
|      | 55   | [Jump Game](https://leetcode.com/problems/jump-game)         | 37.5%      | **Medium** |           |
|      | 56   | [Merge Intervals](https://leetcode.com/problems/merge-intervals) | 44.5%      | **Medium** |           |
|      | 59   | [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii) | 61.8%      | **Medium** |           |
|      | 68   | [Text Justification](https://leetcode.com/problems/text-justification) | 34.4%      | **Hard**   |           |
|      | 79   | [Word Search](https://leetcode.com/problems/word-search)     | 39.4%      | **Medium** |           |
|      | 84   | [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram) | 40.4%      | **Hard**   |           |
|      | 93   | [Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses) | 41.2%      | **Medium** |           |
|      | 124  | [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum) | 37.4%      | **Hard**   |           |
|      | 131  | [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning) | 58.7%      | **Medium** |           |
|      | 132  | [Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii) | 33.0%      | **Hard**   |           |
|      | 134  | [Gas Station](https://leetcode.com/problems/gas-station)     | 44.3%      | **Medium** |           |
|      | 139  | [Word Break](https://leetcode.com/problems/word-break)       | 44.2%      | **Medium** |           |
|      | 146  | [LRU Cache](https://leetcode.com/problems/lru-cache)         | 39.4%      | **Medium** |           |
|      | 160  | [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists) | 49.1%      | **Easy**   |           |
|      | 200  | [Number of Islands](https://leetcode.com/problems/number-of-islands) | 53.2%      | **Medium** |           |
|      | 204  | [Count Primes](https://leetcode.com/problems/count-primes)   | 32.9%      | **Medium** |           |
|      | 207  | [Course Schedule](https://leetcode.com/problems/course-schedule) | 44.9%      | **Medium** |           |
|      | 210  | [Course Schedule II](https://leetcode.com/problems/course-schedule-ii) | 46.1%      | **Medium** |           |
|      | 222  | [Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes) | 54.6%      | **Medium** |           |
|      | 239  | [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum) | 46.1%      | **Hard**   |           |
|      | 283  | [Move Zeroes](https://leetcode.com/problems/move-zeroes)     | 60.3%      | **Easy**   |           |
|      | 286  | [Walls and Gates](https://leetcode.com/problems/walls-and-gates) | 58.8%      | **Medium** |           |
|      | 297  | [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree) | 53.2%      | **Hard**   |           |
|      | 298  | [Binary Tree Longest Consecutive Sequence](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence) | 50.8%      | **Medium** |           |
|      | 322  | [Coin Change](https://leetcode.com/problems/coin-change)     | 39.8%      | **Medium** |           |
|      | 328  | [Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list) | 59.3%      | **Medium** |           |
|      | 340  | [Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters) | 47.1%      | **Medium** |           |
|      | 353  | [Design Snake Game](https://leetcode.com/problems/design-snake-game) | 37.8%      | **Medium** |           |
|      | 394  | [Decode String](https://leetcode.com/problems/decode-string) | 56.0%      | **Medium** |           |
|      | 399  | [Evaluate Division](https://leetcode.com/problems/evaluate-division) | 56.7%      | **Medium** |           |
|      | 403  | [Frog Jump](https://leetcode.com/problems/frog-jump)         | 42.8%      | **Hard**   |           |
|      | 410  | [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum) | 49.8%      | **Hard**   |           |
|      | 412  | [Fizz Buzz](https://leetcode.com/problems/fizz-buzz)         | 66.1%      | **Easy**   |           |
|      | 487  | [Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii) | 48.7%      | **Medium** |           |
|      | 560  | [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k) | 44.1%      | **Medium** |           |
|      | 658  | [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements) | 44.3%      | **Medium** |           |
|      | 670  | [Maximum Swap](https://leetcode.com/problems/maximum-swap)   | 47.3%      | **Medium** |           |
|      | 696  | [Count Binary Substrings](https://leetcode.com/problems/count-binary-substrings) | 64.5%      | **Easy**   |           |
|      | 720  | [Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary) | 50.8%      | **Medium** |           |
|      | 722  | [Remove Comments](https://leetcode.com/problems/remove-comments) | 37.3%      | **Medium** |           |
|      | 773  | [Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle) | 62.9%      | **Hard**   |           |
|      | 780  | [Reaching Points](https://leetcode.com/problems/reaching-points) | 31.4%      | **Hard**   |           |
|      | 787  | [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops) | 36.3%      | **Medium** |           |
|      | 790  | [Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling) | 47.7%      | **Medium** |           |
|      | 489  | [Robot Room Cleaner](https://leetcode.com/problems/robot-room-cleaner) | 75.3%      | **Hard**   |           |
|      | 855  | [Exam Room](https://leetcode.com/problems/exam-room)         | 43.5%      | **Medium** |           |
|      | 886  | [Possible Bipartition](https://leetcode.com/problems/possible-bipartition) | 46.8%      | **Medium** |           |
|      | 946  | [Validate Stack Sequences](https://leetcode.com/problems/validate-stack-sequences) | 65.3%      | **Medium** |           |
|      | 973  | [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin) | 66.0%      | **Medium** |           |
|      | 981  | [Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store) | 52.8%      | **Medium** |           |
|      | 1002 | [Find Common Characters](https://leetcode.com/problems/find-common-characters) | 68.4%      | **Easy**   |           |
|      | 1004 | [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii) | 62.5%      | **Medium** |           |
|      | 1011 | [Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days) | 63.1%      | **Medium** |           |
|      | 1048 | [Longest String Chain](https://leetcode.com/problems/longest-string-chain) | 57.6%      | **Medium** |           |
|      | 1507 | [Reformat Date](https://leetcode.com/problems/reformat-date) | 61.6%      | **Easy**   |           |
|      | 1219 | [Path with Maximum Gold](https://leetcode.com/problems/path-with-maximum-gold) | 65.9%      | **Medium** |           |
|      | 1249 | [Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses) | 65.2%      | **Medium** |           |
|      | 1345 | [Jump Game IV](https://leetcode.com/problems/jump-game-iv)   | 44.4%      | **Hard**   |           |
|      | 1347 | [Minimum Number of Steps to Make Two Strings Anagram](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram) | 75.9%      | **Medium** |           |
|      | 1381 | [Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation) | 77.1%      | **Medium** |           |
|      | 1539 | [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number) | 55.2%      | **Easy**   |           |
|      | 1530 | [Number of Good Leaf Nodes Pairs](https://leetcode.com/problems/number-of-good-leaf-nodes-pairs) | 59.4%      | **Medium** |           |
|      | 1654 | [Minimum Jumps to Reach Home](https://leetcode.com/problems/minimum-jumps-to-reach-home) | 26.0%      | **Medium** |           |
|      | 1650 | [Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii) | 77.5%      | **Medium** |           |
|      | 1774 | [Closest Dessert Cost](https://leetcode.com/problems/closest-dessert-cost) | 46.0%      | **Medium** |           |
|      | 1857 | [Largest Color Value in a Directed Graph](https://leetcode.com/problems/largest-color-value-in-a-directed-graph) | 39.7%      | **Hard**   |           |
|      | 1974 | [Minimum Time to Type Word Using Special Typewriter](https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter) | 72.1%      | **Easy**   |           |
|      | 1996 | [The Number of Weak Characters in the Game](https://leetcode.com/problems/the-number-of-weak-characters-in-the-game) | 32.1%      | **Medium** |           |
|      | 2055 | [Plates Between Candles](https://leetcode.com/problems/plates-between-candles) | 47.2%      | **Medium** |           |



## 0. 压题

### 1. Reaching Points

Given four integers `sx`, `sy`, `tx`, and `ty`, return `true` *if it is possible to convert the point* `(sx, sy)` *to the point* `(tx, ty)` *through some operations**, or* `false` *otherwise*.

The allowed operation on some point `(x, y)` is to convert it to either `(x, x + y)` or `(x + y, y)`.

**Example 1:**

```
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: true
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
```

**Example 2:**

```
Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: false
```

**Example 3:**

```
Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: true
```

**Solution 1: DFS / Brute Force**

```java
class Solution {
    
    //                      (1,1)
    //                  /            \
    //            (1,2)                  (2,1)
    //          /        \               /       \ 
    //      (1,3)        (3,2)       (2,3)       (3,1)
    //    /       \      /     \
    // (4,3)X   (1,4) (5,2)X  (3,5)O
    //           /  \
    //       (5,4)X (1,5)
    //
    // TC = O(2^(tx+ty))
    // SC = O(tx * ty)
    
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        if (sx == tx && sy == ty) {
            return true;
        } 
        
        if (sx > tx || sy > ty) {
            return false;
        }
        
        if (reachingPoints(sx + sy, sy, tx, ty)) {
            return true;
        }
        
        if (reachingPoints(sx, sx + sy, tx, ty)) {
            return true;
        }
        return false;
    }
}
```

**Solution 2: Backward Simple**

```java
class Solution {
    // TC = O(max(tx, ty))
    // SC = O(1)
    while (tx >= sx && ty >= sy) {
        if (sx == tx && sy == ty)
            return true;
        if (tx > ty) tx -= ty;
        else ty -= tx;
    }
    return false;
}
```

**Solution 3: Backward Improved**

```java
class Solution {
    // TC = O(log(max(tx, ty)))
    // SC = O(1)
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        while (tx >= sx && ty >= sy) {
			if (tx == ty) {
				break;
			}
			if (tx > ty) {
				if (ty > sy) {
					tx %= ty;
				} else {
					return (tx - sx) % ty == 0;
				} 
			} else {
				if (tx > sx) {
					ty %= tx;
				} else {
					return (ty - sy) % tx == 0;
				}
			}
		}
		return tx == sx && ty == sy;    
    }
}
```



### 2.  Plates Between Candles

There is a long table with a line of plates and candles arranged on top of it. You are given a **0-indexed** string `s` consisting of characters `'*'` and `'|'` only, where a `'*'` represents a **plate** and a `'|'` represents a **candle**.

You are also given a **0-indexed** 2D integer array `queries` where `queries[i] = [lefti, righti]` denotes the **substring** `s[lefti...righti]` (**inclusive**). For each query, you need to find the **number** of plates **between candles** that are **in the substring**. A plate is considered **between candles** if there is at least one candle to its left **and** at least one candle to its right **in the substring**.

- For example, `s = "||**||**|*"`, and a query `[3, 8]` denotes the substring `"*||***\***|"`. The number of plates between candles in this substring is `2`, as each of the two plates has at least one candle **in the substring** to its left **and** right.

Return *an integer array* `answer` *where* `answer[i]` *is the answer to the* `ith` *query*.

 

**Example 1:**

![ex-1](https://assets.leetcode.com/uploads/2021/10/04/ex-1.png)

```
Input: s = "**|**|***|", queries = [[2,5],[5,9]]
Output: [2,3]
Explanation:
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
```

**Example 2:**

![ex-2](https://assets.leetcode.com/uploads/2021/10/04/ex-2.png)

```
Input: s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
Output: [9,0,0,0,0]
Explanation:
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
```

**Solution**

```java
class Solution {
    
    //   0 1 2 3 4 5 6 7 8 9
    // A * * | * | | * * * |
    // S 0 0 1 1 2 3 3 3 3 4
    // P - - 2 2 4 5 5 5 5 9 
    // N 2 2 2 4 4 5 9 9 9 9 
    // L = N[2] = 2
    // R = P[6] = 5
    // R - L - (S[R] - S[L])  
    
    public int[] platesBetweenCandles(String s, int[][] queries) {
        final int N = s.length();
        int[] psum = new int[N];
        int[] prev = new int[N];
        int[] next = new int[N];
        // Arrays.fill(prev, Integer.MIN_VALUE);
        // w/o above would be fine?
        
        int count = 0;
        int L = Integer.MIN_VALUE;
        for (int i = 0; i < N; i++) {
            if (s.charAt(i) == '|') {
                count += 1;
                L = i;
            } 
            psum[i] = count;
            prev[i] = L;
        }
        
        int n = Integer.MAX_VALUE;
        for (int i = N - 1; i >= 0; i--) {
            if (s.charAt(i) == '|') {
                n = i;
            }
            next[i] = n;
        }
        
        int[] result = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int left = next[queries[i][0]];
            int right = prev[queries[i][1]];
            result[i] = left < right ? right - left - (psum[right] - psum[left]) : 0;
        }
        return result;
    }
    // TC = O(N + Q)
    // SC = O(N + Q)
}
```

### 3. Find Size 3 Inversions in a list

Inversion is a strictly decreasing subsequence of length 3. More formally, given an array, p, an inversion in the array is any time some p[i] > p[j] > p[k] and i < j < k. Given an array of length n, find the number of inversions.

**Example 1**

```
n = 5, arr = [5, 3, 4, 2, 1]
Array inversions are [5, 3, 2], [5,3,1], [5,4,2], [5,4,1], [5,2,1], [3,2,1], [4,2,1]
```

**Example 2**

```
n = 4, arr = [4,2,2,1]
The only inversion is [4,2,1] and we do not count the duplicate inversion.
```

**Solution (Duplicant counted individually)**

```java
public class Solution {
    public int solve(int[] array, int k) {
        
        int count = 0;
		for (int i = 0; i < k - 1; i++) {
			
			int small = 0;
			for (int j = i + 1; j < k; j++) {
				if (array[i] > array[j]) {
					small++;
				}
			}

			int great = 0;
			for (int j = i - 1; j >= 0; j--) {
				if (array[i] < array[j]) {
					great++;
				}
			}
			count += small * great;
		}
		return count;
    }
}
```



### 4.  Reformat Date

Given a `date` string in the form `Day Month Year`, where:

- `Day` is in the set `{"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}`.
- `Month` is in the set `{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}`.
- `Year` is in the range `[1900, 2100]`.

Convert the date string to the format `YYYY-MM-DD`, where:

- `YYYY` denotes the 4 digit year.
- `MM` denotes the 2 digit month.
- `DD` denotes the 2 digit day.

**Example 1:**

```
Input: date = "20th Oct 2052"
Output: "2052-10-20"
```

**Example 2:**

```
Input: date = "6th Jun 1933"
Output: "1933-06-06"
```

**Example 3:**

```
Input: date = "26th May 1960"
Output: "1960-05-26"
```

**Solution**

```java
class Solution {
	private static final Map<String, String> months = getMonths();
    public String reformatDate(String date) {
        String[] ss = date.split("\\s+");
        StringBuilder sb = new StringBuilder();
        sb.append(ss[2]).append("-");
        sb.append(months.get(ss[1])).append("-");
        sb.append(ss[0].length() == 3 ? ("0" + ss[0].substring(0, 1)) : ss[0].substring(0, 2));
        return sb.toString();
    }
    
    private static Map<String, String> getMonths(){
        Map<String, String> months = new HashMap<>();
        months.put("Jan", "01");
        months.put("Feb", "02");
        months.put("Mar", "03");
        months.put("Apr", "04");
        months.put("May", "05");
        months.put("Jun", "06");
        months.put("Jul", "07");
        months.put("Aug", "08");
        months.put("Sep", "09");
        months.put("Oct", "10");
        months.put("Nov", "11");
        months.put("Dec", "12");
        return months;
    }
}
```



### 5. Design a Stack With Increment Operation

Design a stack which supports the following operations.

Implement the `CustomStack` class:

- `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.
- `void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.
- `int pop()` Pops and returns the top of stack or **-1** if the stack is empty.
- `void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, just increment all the elements in the stack.

 

**Example 1:**

```
Input
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack customStack = new CustomStack(3); // Stack is Empty []
customStack.push(1);                          // stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.push(3);                          // stack becomes [1, 2, 3]
customStack.push(4);                          // stack still [1, 2, 3], Don't add another elements as size is 4
customStack.increment(5, 100);                // stack becomes [101, 102, 103]
customStack.increment(2, 100);                // stack becomes [201, 202, 103]
customStack.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
customStack.pop();                            // return 202 --> Return top of the stack 102, stack becomes [201]
customStack.pop();                            // return 201 --> Return top of the stack 101, stack becomes []
customStack.pop();                            // return -1 --> Stack is empty return -1.
```

 **Solution**

```java
class CustomStack {
    
    private int maxSize;
    private int[] increase;
    private Stack<Integer> stack;
    
    public CustomStack(int maxSize) {
        this.maxSize = maxSize;
        increase = new int[maxSize];
        stack = new Stack<>();
    }
    
    public void push(int x) {
        if (stk.size() < maxSize) {
            stk.push(x);
        }
    }
    
    public int pop() {
        int i = stack.size() - 1;
        if (i < 0) {
            return -1;
        }
        if (i > 0) {
            increase[i - 1] += increase[i];
        }
        int ret = stack.pop() + increase[i];
        increase[i] = 0;
        return res;
    }
    
    public void increment(int k, int val) {
        int i = Math.min(k, stack.size()) - 1;
        if (i >= 0) {
            increase[i] += val;
        }
    }
}
// size = 10
// stk = [ 1 2 3 4 5      
// inc = [ 0 0 2 0 1 0 0 0 0 0 ] 
//
/**
 * Your CustomStack object will be instantiated and called as such:
 * CustomStack obj = new CustomStack(maxSize);
 * obj.push(x);
 * int param_2 = obj.pop();
 * obj.increment(k,val);
 */
```



### 6. Dominos Tiling 3D

Given tiles of dimensions 1 x 1 x 2, determine how many ways they can be arranged to form a rectangular solid of dimensions 2 x 2 x n.

**Example** 

if n = 1, there are two ways of doing so:

The number of permutations increases quickly, so the return value should be modulo (109+7). See the samples below for the n = 2 solution diagrams.

**Function Description**

Complete the function ways in the editor below. The function should return an array of integers that represent the number of ways each solid can be formed.

**Solution**

```java
public static long solve(int n) {
    if (n == 1) {
        return 2;
    }
    
    long f1 = 1;
    long f2 = 2;
    long p = 0;
    
    for (int i = 0; i < n - 1; i++) {
        long f1Temp = f1;
        f1 = f2;
        f2 = (5 * f1Temp + 2 * f2 + 4 * p) % MOD;
        p = (p + f1Temp) % MOD;
    }
    return f2;
}
```



## 0.2. 历年真题

### 1. Circular Printer

A Company has invented a circular printer -- a wheel with letters A through Z in sequence. It wraps so A and Z are adjacent. The printer has a pointer that is initially at 'A', Moving from any character to any adjacent character takes 1 second. It can move in either direction. Given a string of letters, what is the minimum time needed to print the string?

**Example 1** 

```
s = "BZA"
time = 1 + 2 + 1 = 4 sec
A to B = 1 sec, B to Z = 2 sec (not 24 sec), Z to A = 1 sec
so 4 secs total
```

**Example 2**

```
s = "AZGB"
time = 0 + 1 + 7 + 5 = 13 sec
```

**Example 3**

```
s = "ZNMD"
time = 1 + 12 + 1 + 9 = 23 sec
```

**Solution**

```java
public static long getTime(String str) {
    // 0 1 2 3 4 5 6 7 8 
    // B Z A
    //   i 
    // 
    long time = 0;
    for (int i = 0; i < str.length(); i++) {
        long dis = Math.abs(str.charAt(i) - (i == 0 ? 'A' : str.charAt(i - 1)));
        time += Math.min(dis, 26 - dis);
    }
    return time;
}
```



### 2. Reformat Date

Given a `date` string in the form `Day Month Year`, where:

- `Day` is in the set `{"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}`.
- `Month` is in the set `{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}`.
- `Year` is in the range `[1900, 2100]`.

Convert the date string to the format `YYYY-MM-DD`, where:

- `YYYY` denotes the 4 digit year.
- `MM` denotes the 2 digit month.
- `DD` denotes the 2 digit day.

 

**Example 1:**

```
Input: date = "20th Oct 2052"
Output: "2052-10-20"
```

**Example 2:**

```
Input: date = "6th Jun 1933"
Output: "1933-06-06"
```

**Example 3:**

```
Input: date = "26th May 1960"
Output: "1960-05-26"
```

**Solution**

```java
class Solution {
	private static final Map<String, String> months = getMonths();
    public String reformatDate(String date) {
        String[] ss = date.split("\\s+");
        StringBuilder sb = new StringBuilder();
        sb.append(ss[2]).append("-");
        sb.append(months.get(ss[1])).append("-");
        sb.append(ss[0].length() == 3 ? ("0" + ss[0].substring(0, 1)) : ss[0].substring(0, 2));
        return sb.toString();
    }
    
    private static Map<String, String> getMonths(){
        Map<String, String> months = new HashMap<>();
        months.put("Jan", "01");
        months.put("Feb", "02");
        months.put("Mar", "03");
        months.put("Apr", "04");
        months.put("May", "05");
        months.put("Jun", "06");
        months.put("Jul", "07");
        months.put("Aug", "08");
        months.put("Sep", "09");
        months.put("Oct", "10");
        months.put("Nov", "11");
        months.put("Dec", "12");
        return months;
    }
}
```



### 3.  Ancester Names

Given a list of strings comprised of a name and a Roman numeral, sort the list first by name, then by decimal value of the Roman numeral

**Example**

```
[ Steven XL, Steven XVI, David IX, Mary XV, Mary XIII, Mary XX ] 
is sorted into 
[ David IX, Mary XIII, Mary XV, Mary XX, Steven XVI, Steven XL ]
```

**Solution**

```java
public class Solution {
	public String[] getSrotedList(String[] names) {
		Arrays.sort(names, (s1, s2) -> {
			String[] arr1 = s1.split(" ");
			String[] arr2 = s2.split(" ");

			int value1 = romanToInt(arr1[1]);
			int value2 = romanToInt(arr2[1]);

			if (arr1[0].equals(arr2[0])) {
				if (value1 > value2) {
					return 1;
				} else {
					return -1;
				}
			} else {
				return arr1[0].compareTo(arr2[0]);
			}
		});
		return names;
    }
    
    private int romanToInt(String s) {
        Map<String, Integer> values = new HashMap<>();
        values.put("I", 1);
        values.put("V", 5);
        values.put("X", 10);
        values.put("L", 50);
        values.put("C", 100);
        values.put("D", 500);
        values.put("M", 1000);
        values.put("IV", 4);
        values.put("IX", 9);
        values.put("XL", 40);
        values.put("XC", 90);
        values.put("CD", 400);
        values.put("CM", 900);
        
        int sum = 0;
        int i = 0;
        while (i < s.length()) {
            if (i < s.length() - 1) {
                String doubleSymbol = s.substring(i, i + 2);
                if (values.containsKey(doubleSymbol)) {
                    sum += values.get(doubleSymbol);
                    i += 2;
                    continue;
                }
            }
            String singleSymbol = s.substring(i, i + 1);
            sum += values.get(singleSymbol);
            i += 1;
        }
        return sum;
    }
}
```



### 4. Plates Between Candles

There is a long table with a line of plates and candles arranged on top of it. You are given a **0-indexed** string `s` consisting of characters `'*'` and `'|'` only, where a `'*'` represents a **plate** and a `'|'` represents a **candle**.

You are also given a **0-indexed** 2D integer array `queries` where `queries[i] = [lefti, righti]` denotes the **substring** `s[lefti...righti]` (**inclusive**). For each query, you need to find the **number** of plates **between candles** that are **in the substring**. A plate is considered **between candles** if there is at least one candle to its left **and** at least one candle to its right **in the substring**.

- For example, `s = "||**||**|*"`, and a query `[3, 8]` denotes the substring `"*||***\***|"`. The number of plates between candles in this substring is `2`, as each of the two plates has at least one candle **in the substring** to its left **and** right.

Return *an integer array* `answer` *where* `answer[i]` *is the answer to the* `ith` *query*.

 

**Example 1:**

![ex-1](https://assets.leetcode.com/uploads/2021/10/04/ex-1.png)

```
Input: s = "**|**|***|", queries = [[2,5],[5,9]]
Output: [2,3]
Explanation:
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
```

**Example 2:**

![ex-2](https://assets.leetcode.com/uploads/2021/10/04/ex-2.png)

```
Input: s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
Output: [9,0,0,0,0]
Explanation:
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
```

**Solution**

```java
class Solution {
    
    //   0 1 2 3 4 5 6 7 8 9
    // A * * | * | | * * * |
    // S 0 0 1 1 2 3 3 3 3 4
    // P - - 2 2 4 5 5 5 5 9 
    // N 2 2 2 4 4 5 9 9 9 9 
    // L = N[2] = 2
    // R = P[6] = 5
    // R - L - (S[R] - S[L])  
    
    public int[] platesBetweenCandles(String s, int[][] queries) {
        final int N = s.length();
        int[] psum = new int[N];
        int[] prev = new int[N];
        int[] next = new int[N];
        // Arrays.fill(prev, Integer.MIN_VALUE);
        // w/o above would be fine?
        
        int count = 0;
        int L = Integer.MIN_VALUE;
        for (int i = 0; i < N; i++) {
            if (s.charAt(i) == '|') {
                count += 1;
                L = i;
            } 
            psum[i] = count;
            prev[i] = L;
        }
        
        int n = Integer.MAX_VALUE;
        for (int i = N - 1; i >= 0; i--) {
            if (s.charAt(i) == '|') {
                n = i;
            }
            next[i] = n;
        }
        
        int[] result = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int left = next[queries[i][0]];
            int right = prev[queries[i][1]];
            result[i] = left < right ? right - left - (psum[right] - psum[left]) : 0;
        }
        return result;
    }
}
```



### 5. Design a Stack With Increment Operation

Design a stack which supports the following operations.

Implement the `CustomStack` class:

- `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.
- `void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.
- `int pop()` Pops and returns the top of stack or **-1** if the stack is empty.
- `void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, just increment all the elements in the stack.

 

**Example 1:**

```
Input
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack customStack = new CustomStack(3); // Stack is Empty []
customStack.push(1);                          // stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.push(3);                          // stack becomes [1, 2, 3]
customStack.push(4);                          // stack still [1, 2, 3], Don't add another elements as size is 4
customStack.increment(5, 100);                // stack becomes [101, 102, 103]
customStack.increment(2, 100);                // stack becomes [201, 202, 103]
customStack.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
customStack.pop();                            // return 202 --> Return top of the stack 102, stack becomes [201]
customStack.pop();                            // return 201 --> Return top of the stack 101, stack becomes []
customStack.pop();                            // return -1 --> Stack is empty return -1.
```

 **Solution**

```java
class CustomStack {
    
    private int maxSize;
    private int[] increase;
    private Stack<Integer> stack;
    
    public CustomStack(int maxSize) {
        this.maxSize = maxSize;
        increase = new int[maxSize];
        stack = new Stack<>();
    }
    
    public void push(int x) {
        if (stk.size() < maxSize) {
            stk.push(x);
        }
    }
    
    public int pop() {
        int i = stack.size() - 1;
        if (i < 0) {
            return -1;
        }
        if (i > 0) {
            increase[i - 1] += increase[i];
        }
        int ret = stack.pop() + increase[i];
        increase[i] = 0;
        return res;
    }
    
    public void increment(int k, int val) {
        int i = Math.min(k, stack.size()) - 1;
        if (i >= 0) {
            increase[i] += val;
        }
    }
}
// size = 10
// stk = [ 1 2 3 4 5      
// inc = [ 0 0 2 0 1 0 0 0 0 0 ] 
//
/**
 * Your CustomStack object will be instantiated and called as such:
 * CustomStack obj = new CustomStack(maxSize);
 * obj.push(x);
 * int param_2 = obj.pop();
 * obj.increment(k,val);
 */
```



### 6. Find Size 3 Inversions in a list

Inversion is a strictly decreasing subsequence of length 3. More formally, given an array, p, an inversion in the array is any time some p[i] > p[j] > p[k] and i < j < k. Given an array of length n, find the number of inversions.

**Example 1**

```
n = 5, arr = [5, 3, 4, 2, 1]
Array inversions are [5, 3, 2], [5,3,1], [5,4,2], [5,4,1], [5,2,1], [3,2,1], [4,2,1]
```

**Example 2**

```
n = 4, arr = [4,2,2,1]
The only inversion is [4,2,1] and we do not count the duplicate inversion.
```

**Solution (Duplicant counted individually)**

```java
public class Solution {
    public int solve(int[] array, int k) {
        
        int count = 0;
		for (int i = 0; i < k - 1; i++) {
			
			int small = 0;
			for (int j = i + 1; j < k; j++) {
				if (array[i] > array[j]) {
					small++;
				}
			}

			int great = 0;
			for (int j = i - 1; j >= 0; j--) {
				if (array[i] < array[j]) {
					great++;
				}
			}
			count += small * great;
		}
		return count;
    }
}
```

**Solution (Duplicant counted as one) NOT CORRECT!!!**

```java
public class Solution {
    public int solve(int[] array) {
        final int N = array.length;
        Set<Integer> seen = new HashSet<>();
        int count = 0;
        for (int i = 0; i < N; i++) {
            if (!seen.contains(array[i])) {
                int small = 0;
                for (int j = i + 1; j < N; j++) {
                    if (array[i] > array[j]) {
                        small++;
                    }
                }
                int big = 0;
                for (int j = i - 1; j >= 0; j--) {
                    if (array[j] > array[i]) {
                        big++;
                    }
                }
                count += small * big;
                seen.add(array[i]);
            }
        }
        return count;
    }
}
```



### 7.  Finding Substring

#### 7.1. Smallest and Largest

Given a string and an integer, find the lexicographically smallest and largest substring of length k in Lexicography order a.k.a alphabetical order or dictionary order:

```
A < B <... < Y < Z < a < b <.. < y < z
```

**Examples**

```
Input : String: hello
        Size: 2
        Distinct Substring: [el, he, ll, lo]
Output : Smallest Substring: el
         Largest Substring: lo

Input : String: geeksforgeeks
        Size: 3
        Distinct Substring: [eek, eks, for, gee, ksf, org, rge, sfo]
Output : Smallest Substring: eek
         Largest Substring: sfo
```

**Solution**

```java
public class Solution {
    public static void getSmallestAndLargest(String s, int k) {
        // Initialize min and max as first substring of size k
        String currStr = s.substring(0, k);
        String lexMin = currStr;
        String lexMax = currStr;
  
        // Consider all remaining substrings. We consider
        // every substring ending with index i.
        for (int i = k; i < s.length(); i++) {
            currStr = currStr.substring(1, k) + s.charAt(i);
            if (lexMax.compareTo(currStr) < 0)    
                 lexMax = currStr;
            if (lexMin.compareTo(currStr) > 0)
                 lexMin = currStr;           
        }
 
        // Print result.
        System.out.println(lexMin);
        System.out.println(lexMax);
    }
}
```



#### 7.2. Smallest with size k and N ones

Given a string of only 1's and 0's. Find lexically smallest substring with length K and N ones. Return null if such substring does not exist

**Example**

```
str = "01110101001"
solve(str, K=3, N=2) = "011"
solve(str, K=4, N=2) = "0101"
```

**Solution**

```java
public class Solution {
    // TC = O(K + N)
    // SC = O(K)
    public String solve(String str, int k, int n) {
        String cur = str.substring(0, k);
        int count = 0;
        for (int i = 0; i < cur.length(); i++) {
            if (cur.charAt(i) == '1') {
                count++;
            }
        }
        
        String min = null;
        for (int i = k - 1; i < str.length(); i++) {
            if (count == n && (min == null || cur.compareTo(min) < 0)) {
                min = cur;
            }
            if (cur.charAt(0) == '1') {
                count--;
            }
            if (str.charAt(i) == '1') {
                count++;
            }
            cur = cur.substring(1, k) + str.charAt(i);
        }
        return min;
    }
}
```



## 1. Romans Numerical

### 1.1. Integer to Roman

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

- `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
- `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
- `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

**Example 1:**

```
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
```

**Example 2:**

```
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
```

**Example 3:**

```
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

**Solution**

```java
class Solution {
    
    private static final int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    private static final String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
    
    public String intToRoman(int num) {
        StringBuilder str = new StringBuilder();
        
        for (int i = 0; i < values.length && num > 0; i++) {
            while (values[i] <= num) {
                num -= values[i];
                str.append(symbols[i]);
            }
        }
        
        return str.toString();
    }
}
// The largest roman number that the current symbols can represent is 3999 => MMMDCCCLXXXVIII
// Therefore TC = O(1) and SC = O(1)
```



### 1.2. Roman to Integer

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

- `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
- `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
- `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer.

**Example 1:**

```
Input: s = "III"
Output: 3
Explanation: III = 3.
```

**Example 2:**

```
Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
```

**Example 3:**

```
Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

**Solution**

```java
class Solution {
    public int romanToInt(String s) {
        Map<String, Integer> values = new HashMap<>();
        values.put("I", 1);
        values.put("V", 5);
        values.put("X", 10);
        values.put("L", 50);
        values.put("C", 100);
        values.put("D", 500);
        values.put("M", 1000);
        values.put("IV", 4);
        values.put("IX", 9);
        values.put("XL", 40);
        values.put("XC", 90);
        values.put("CD", 400);
        values.put("CM", 900);
        
        int sum = 0;
        int i = 0;
        while (i < s.length()) {
            if (i < s.length() - 1) {
                String doubleSymbol = s.substring(i, i + 2);
                if (values.containsKey(doubleSymbol)) {
                    sum += values.get(doubleSymbol);
                    i += 2;
                    continue;
                }
            }
            String singleSymbol = s.substring(i, i + 1);
            sum += values.get(singleSymbol);
            i += 1;
        }
        return sum;
    }
}
// The largest roman number that the current symbols can represent is 3999 => MMMDCCCLXXXVIII
// Therefore TC = O(1) and SC = O(1)
```



## 2. Longest Palindromic Substring

Given a string `s`, return *the longest palindromic substring* in `s`.

**Example 1:**

```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```

**Example 2:**

```
Input: s = "cbbd"
Output: "bb"
```

**Solution**

```java
class Solution {
    public String longestPalindrome(String s) {
        int start = 0;
        int end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
    
    private int expand(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
// TC = O(N^2)
// SC = O(1)
```



## 3. Search in Rotated Sorted Array

There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Example 3:**

```
Input: nums = [1], target = 0
Output: -1
```

**Solution**

```java
class Solution {
    // TC = O(log N)
    // SC = O(1)
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] >= nums[left]) {
                if (target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (target <= nums[right] && target > nums[mid]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

## 4. Valid Parentheses

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.

**Example 1:**

```
Input: s = "()"
Output: true
```

**Example 2:**

```
Input: s = "()[]{}"
Output: true
```

**Example 3:**

```
Input: s = "(]"
Output: false
```

**Solution**

```java
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<>();
        
        map.put(')', '(');
        map.put('}', '{');
        map.put(']', '[');
    
        Stack<Character> stack = new Stack<>();
        
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) {
                char topElement = stack.empty() ? '#' : stack.pop();
                if (topElement != map.get(c)) {
                    return false;
                }
            } else {
                stack.push(c);
            }
        }
        return stack.isEmpty();
    }
}
```

## 5. Search Insert Position

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

 

**Example 1:**

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

**Example 2:**

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

**Example 3:**

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```

**Solution**

```java
class Solution {
    // TC = O(log N) SC = O(1)
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```



## 6. Sudoku Solver

Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy **all of the following rules**:

1. Each of the digits `1-9` must occur exactly once in each row.
2. Each of the digits `1-9` must occur exactly once in each column.
3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

The `'.'` character indicates empty cells.

 

**Example 1:**

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:
```

 ![250px-Sudoku-by-L2G-20050714_solution.svg](C:\Users\EddyM\Desktop\KnowledgeBase\Assets\250px-Sudoku-by-L2G-20050714_solution.svg.png)

**Solution**

```java
class Solution {
    public void solveSudoku(char[][] board) {
        int[] first = nextEmptySlot(board, 0, 0);
        helper(board, first[0], first[1]);
    }
    
    private boolean helper(char[][] board, int i, int j) {
        if (i == -1 && j == -1) {
            return true;
        }
        for (char n = '1'; n <= '9'; n++) {
            board[i][j] = n;
            if (isValid(board, i, j)) {
                int[] next = nextEmptySlot(board, i, j);
                if (helper(board, next[0], next[1])) {
                    return true;
                }
            }
            board[i][j] = '.';
        }
        return false;
    }
    
    private boolean isValid(char[][] board, int row, int col) {
        for (int i = 0; i < board.length; i++) {
            if (board[i][col] == board[row][col] && i != row) {
                return false;
            }
        }
        for (int j = 0; j < board[0].length; j++) {
            if (board[row][j] == board[row][col] && j != col) {
                return false;
            }
        }
        
        int sectionRow = (row / 3) * 3;     // !!!! THIS LINES !!!!!
        int sectionCol = (col / 3) * 3;     // !!!! LOOK AT THIS !!!!
        
        for (int i = sectionRow; i < sectionRow + 3; i++) {
            for (int j = sectionCol; j < sectionCol + 3; j++) {
                if (board[i][j] == board[row][col] && i != row && j != col ) {
                    return false;
                }
            }
        }
        return true;
    }
    
    private int[] nextEmptySlot(char[][] board, int startI, int startJ) {
        for (int i = startI; i < board.length; i++) {
            int j = i == startI ? startJ : 0;
            while (j < board[0].length) {
                if (board[i][j] == '.') {
                    return new int[]{i, j};
                }
                j++;
            }
        }
        return new int[]{-1, -1};
    }
}
```



## 7. Reaching Points

Given four integers `sx`, `sy`, `tx`, and `ty`, return `true` *if it is possible to convert the point* `(sx, sy)` *to the point* `(tx, ty)` *through some operations**, or* `false` *otherwise*.

The allowed operation on some point `(x, y)` is to convert it to either `(x, x + y)` or `(x + y, y)`.

**Example 1:**

```
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: true
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
```

**Example 2:**

```
Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: false
```

**Example 3:**

```
Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: true
```

**Solution 1: DFS / Brute Force**

```java
class Solution {
    
    //                      (1,1)
    //                  /            \
    //            (1,2)                  (2,1)
    //          /        \               /       \ 
    //      (1,3)        (3,2)       (2,3)       (3,1)
    //    /       \      /     \
    // (4,3)X   (1,4) (5,2)X  (3,5)O
    //           /  \
    //       (5,4)X (1,5)
    //
    // TC = O(2^(tx+ty))
    // SC = O(tx * ty)
    
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        if (sx == tx && sy == ty) {
            return true;
        } 
        
        if (sx > tx || sy > ty) {
            return false;
        }
        
        if (reachingPoints(sx + sy, sy, tx, ty)) {
            return true;
        }
        
        if (reachingPoints(sx, sx + sy, tx, ty)) {
            return true;
        }
        return false;
    }
}
```

**Solution 2: Backward Simple**

```java
class Solution {
    // TC = O(max(tx, ty))
    // SC = O(1)
    while (tx >= sx && ty >= sy) {
        if (sx == tx && sy == ty)
            return true;
        if (tx > ty) tx -= ty;
        else ty -= tx;
    }
    return false;
}
```

**Solution 3: Backward Improved**

```java
class Solution {
    // TC = O(log(max(tx, ty)))
    // SC = O(1)
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        while (tx >= sx && ty >= sy) {
			if (tx == ty) {
				break;
			}
			if (tx > ty) {
				if (ty > sy) {
					tx %= ty;
				} else {
					return (tx - sx) % ty == 0;
				} 
			} else {
				if (tx > sx) {
					ty %= tx;
				} else {
					return (ty - sy) % tx == 0;
				}
			}
		}
		return tx == sx && ty == sy;    
    }
}
```



## 8. Text Justification

Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified and no extra space is inserted between words.

**Note:**

- A word is defined as a character sequence consisting of non-space characters only.
- Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
- The input array `words` contains at least one word.

 

**Example 1:**

```
Input: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
```

**Example 2:**

```
Input: words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified becase it contains only one word.
```

**Example 3:**

```
Input: words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
```

**Solution**

```java
class Solution {
    public List<String> fullJustify(String[] words, int lineLength) {
        List<String> lines = new ArrayList<>();
        // 0      1    2    3         4    5      6
        // this , is , an , example , of , text , justification.
        //                                        i
        //                                                        j
        // 4      2    2    7         2    4      13
        // total = 13
       
        int i = 0;
        int j = 0;
        int totalLength = 0;
        while (j < words.length) {
            totalLength += words[j].length();
            if (totalLength + (j - i) > lineLength) {
                addLine(words, i, j, lineLength, j - i == 1, lines);
                i = j;
                totalLength = 0;
            } else {
                j++;
            }
        }
        if (i != words.length) {
            addLine(words, i, j, lineLength, true, lines);
        }
        return lines;
    }
    
    private void addLine(String[] words, int start, int end, int lineLength, boolean justifyLeft, List<String> lines) {
        // E - S = 3 words
        // 3 words - 1 = 2 spaces between
        // 3 words total length of 8
        // (16 - 8) / 2 = 4 spaces each
        
        StringBuilder str = new StringBuilder();
        
        if (justifyLeft) {
            int sum = 0;
            for (int i = start; i < end; i++) {
                str.append(words[i]);
                addSpace(str, i == end - 1 ? 0 : 1);
            }
            addSpace(str, lineLength - str.length());  // NOTE: this is how you fill remaining with spaces
        } else {
            int totalWordLength = 0;
            for (int i = start; i < end; i++) {
                totalWordLength += words[i].length();
            }
            int totalSpace = lineLength - totalWordLength;
            int spaceBetween = totalSpace / (end - start - 1);
            int leftOver = totalSpace % (end - start - 1);
            for (int i = start; i < end; i++) {
                str.append(words[i]);
                if (i != end - 1) {
                    addSpace(str, spaceBetween);
                    if (leftOver != 0) {
                        addSpace(str, 1);
                        leftOver--;
                    }
                }
            }
        }
        lines.add(str.toString());
    }
    
    private void addSpace(StringBuilder str, int count) {
        for (int i = 0; i < count; i++) {
            str.append(" ");
        }
    }   
}
```



## 9. Serialize and Deserialize Binary Tree

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

**Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://leetcode.com/faq/#binary-tree). You do not necessarily need to follow this format, so please be creative and **come up with different approaches yourself.**

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Solution**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        return sHelper(root, "");
    }
    
    private String sHelper(TreeNode root, String str) {
        if (root == null) {
            str += "null,";
        } else {
            str += str.valueOf(root.val) + ",";
            str = sHelper(root.left, str);
            str = sHelper(root.right, str);
        }
        return str;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] dataArray = data.split(",");
        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));
        return dHelper(dataList);
    }
    
    private TreeNode dHelper(List<String> list) {
        if (list.get(0).equals("null")) {
            list.remove(0);
            return null;
        }
        
        TreeNode root = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        root.left = dHelper(list);
        root.right = dHelper(list);
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



## 10. Gas Station

There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.

You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**

 

**Example 1:**

```
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
```

**Example 2:**

```
Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
```

**Solution**

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int totalTank = 0;
        int curTank = 0;
        int start = 0;
        for (int i = 0; i < n; i++) {
            totalTank += gas[i] - cost[i];
            curTank += gas[i] - cost[i];
            if (curTank < 0) {
                start = i + 1;
                curTank = 0;
            }
        }
        return totalTank >= 0 ? start : -1;
    }
}
```



## 11. Binary Tree Longest Consecutive Sequence

Given the `root` of a binary tree, return *the length of the longest consecutive sequence path*.

The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse).

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg)

```
Input: root = [1,null,3,2,4,null,null,null,5]
Output: 3
Explanation: Longest consecutive sequence path is 3-4-5, so return 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg)

```
Input: root = [2,null,3,2,null,1]
Output: 2
Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.
```

**Solution**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public int longestConsecutive(TreeNode root) {
        int[] max = {Integer.MIN_VALUE};
        helper(root, max);
        return max[0];
    }
    
    private int helper(TreeNode root, int[] max) {
        if (root == null) {
            return 0;
        }
        
        int left = helper(root.left, max) + 1;
        int right = helper(root.right, max) + 1;
        
        if (root.left != null && root.val != root.left.val - 1) {
            left = 1;
        }
        if (root.right != null && root.val != root.right.val - 1) {
            right = 1;
        }
        int length = Math.max(left, right);
        max[0] = Math.max(max[0], length);
        return length;
    }
}
```



## 12. Count Primes

Given an integer `n`, return *the number of prime numbers that are strictly less than* `n`.

**Example 1:**

```
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
```

**Example 2:**

```
Input: n = 0
Output: 0
```

**Example 3:**

```
Input: n = 1
Output: 0
```

**Solution**

```java
class Solution {
    // 1 2 3 4 5 6 7 8 9 10
    // F F F T F T F T T T 
    //             i
    //   j
    // count = 2
    public int countPrimes(int n) {
        boolean[] notPrime = new boolean[n];
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (!notPrime[i]) {
                count++;
                for (int j = 2; i * j < n; j++) {
                    notPrime[i * j] = true;
                }
            }
        }
        return count;
    }
}
```



## 13. Minimum Number of Steps to Make Two Strings Anagram

You are given two strings of the same length `s` and `t`. In one step you can choose **any character** of `t` and replace it with **another character**.

Return *the minimum number of steps* to make `t` an anagram of `s`.

An **Anagram** of a string is a string that contains the same characters with a different (or the same) ordering.

 

**Example 1:**

```
Input: s = "bab", t = "aba"
Output: 1
Explanation: Replace the first 'a' in t with b, t = "bba" which is anagram of s.
```

**Example 2:**

```
Input: s = "leetcode", t = "practice"
Output: 5
Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.
```

**Example 3:**

```
Input: s = "anagram", t = "mangaar"
Output: 0
Explanation: "anagram" and "mangaar" are anagrams. 
```

**Solution**

```java
class Solution {
    public int minSteps(String s, String t) {
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        int steps = 0;
        for (int step : count) {
            if (step > 0) {
                steps += step;
            }
        }
        return steps;
    }
}
```





